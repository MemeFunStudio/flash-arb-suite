<!doctype html><html lang="en"><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flash Executor — Devnet (NO-MODULE)</title>
<style>
:root{--bg:#0f1221;--card:#171a2e;--ink:#e8eaf6}
*{box-sizing:border-box}body{margin:0;background:var(--bg);color:var(--ink);font:14px ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
.wrap{max-width:1100px;margin:0 auto;padding:24px}
.card{background:var(--card);border:1px solid #242845;border-radius:14px;padding:16px;margin:12px 0}
.row{display:grid;grid-template-columns:1fr 1fr;gap:16px}
input,select,textarea,button{width:100%;padding:10px;border-radius:10px;border:1px solid #2b2f4a;background:#0d1022;color:var(--ink)}
textarea{height:160px}
button{cursor:pointer;background:#1b2040}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace}
.small{font-size:12px;color:#96a0b8}
.tx{border-left:3px solid #2f3563;padding-left:10px;margin:8px 0}
a{color:#9ecbff}
.bad{color:#ff6b6b}
</style>

<div class="wrap">
  <h1>⚡ Flash Executor — Devnet <span class="mono" style="padding:3px 8px;border:1px solid #22284d;border-radius:999px;background:#0b0f24">NO-MODULE • local web3.iife.js • LIVE • no mocks</span></h1>
  <p class="small">Every action below sends a real transaction to Devnet and prints a Solana Explorer link after on-chain confirmation.</p>

  <div class="card">
    <div class="row">
      <div>
        <label>RPC</label>
        <div style="display:flex;gap:8px">
          <select id="rpc"><option>https://api.devnet.solana.com</option></select>
          <button id="ping">Ping</button>
        </div>
        <div class="small">Status: <span id="rpcStatus" class="mono">—</span></div>
      </div>
      <div>
        <label>Program ID</label>
        <input id="programId" class="mono" value="9ckBy54vd9G6FmR63Z4PoLtNq8rbtoYzhVbJGx458Kmn"/>
        <div class="small">From contract: <span class="mono">declare_id!(…)</span></div>
      </div>
    </div>

    <div class="row" style="margin-top:12px">
      <div>
        <button id="connect">Connect Phantom</button>
        <div class="small">Wallet: <span id="wallet" class="mono">—</span></div>
        <div class="small">Balance: <span id="bal" class="mono">—</span></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="airdrop">Airdrop 1 SOL</button><button id="balance">Refresh Balance</button>
        </div>
      </div>
      <div>
        <label>Global Account (PDA or existing)</label>
        <input id="globalAddr" class="mono" placeholder="Paste global account address if already created"/>
        <div class="small">Owner (optional): <span id="globalOwner" class="mono">—</span></div>
      </div>
    </div>
  </div>

  <h2>Derivations & Vault</h2>
  <div class="card">
    <div class="row">
      <div>
        <label>Mint (token to arbitrate)</label>
        <input id="mint" class="mono" placeholder="Devnet token mint"/>
        <div class="small">Token Program: <span id="whichTokenProg" class="mono">—</span></div>
      </div>
      <div>
        <label>Pool Params</label>
        <div style="display:grid;grid-template-columns:1fr auto;gap:10px">
          <input id="minBps" type="number" value="30"/><button id="derivePdas">Derive PDAs</button>
        </div>
        <div class="small">Pool PDA: <span id="poolPda" class="mono">—</span></div>
        <div class="small">Vault Auth PDA: <span id="vaultAuth" class="mono">—</span></div>
        <div class="small">Vault ATA: <span id="vaultAta" class="mono">—</span></div>
      </div>
    </div>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button id="createVaultAta">Create Vault ATA</button>
      <button id="vaultBal">Vault Balance</button>
      <span class="small">Amount: <span id="vaultAmount" class="mono">—</span></span>
    </div>
  </div>

  <h2>Execute Route</h2>
  <div class="card">
    <div class="row">
      <div>
        <label>Principal (base units, u64)</label>
        <input id="principal" class="mono" value="1000000"/>
        <div class="small">Compute: units <input id="cuLimit" class="mono" value="1200000" style="width:120px"> • microLamports <input id="cuPrice" class="mono" value="0" style="width:120px"></div>
      </div>
      <div>
        <label>Route JSON</label>
        <textarea id="route" class="mono" placeholder='[{"programId":"DEX_PROGRAM","metas":[{"pubkey":"...", "isSigner":false, "isWritable":true}], "data":"hex-encoded-cpi-data"}]'></textarea>
      </div>
    </div>
    <div style="display:flex;gap:8px;margin-top:8px"><button id="execute">Execute Route</button></div>
  </div>

  <h2>DEX Program Verifier (optional)</h2>
  <div class="card">
    <label>Program IDs (one per line)</label>
    <textarea id="dexList" class="mono" placeholder="whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc&#10;675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"></textarea>
    <div style="display:flex;gap:8px;margin-top:8px"><button id="verifyDex">Verify on-chain</button></div>
    <div class="small">Results: <span id="dexResults" class="mono">—</span></div>
  </div>

  <h2>TX Log</h2><div class="card" id="log"></div>
</div>

<script src="./vendor/web3.iife.js?v=1"></script>
<script>
(function(){
const web3 = window.solanaWeb3;
const $=id=>document.getElementById(id);
const logDiv=$('log'); const log=(m,ok=true)=>{const d=document.createElement('div');d.className='tx';d.innerHTML=ok?m:`<span class="bad">${m}</span>`;logDiv.prepend(d);};

const EXPLORER='https://explorer.solana.com';
const exTx=s=>`<a target="_blank" class="mono" href="${EXPLORER}/tx/${s}?cluster=devnet">${s}</a>`;
const exAddr=s=>`<a target="_blank" class="mono" href="${EXPLORER}/address/${s}?cluster=devnet">${s}</a>`;

async function verifyOnChain(conn, signature){
  try{
    const tx = await conn.getTransaction(signature,{maxSupportedTransactionVersion:0});
    if (tx && !tx.meta?.err){ log(`Verified ✓ ${exTx(signature)}`); return; }
    const st = await conn.getSignatureStatuses([signature], {searchTransactionHistory:true});
    const s = st.value[0]; const ok = !!s && !s.err;
    log(`${ok?'Verified ✓':'Tx error'} ${exTx(signature)}`, ok);
  }catch(e){ log(`Verification failed for ${exTx(signature)}: ${e.message}`, false); }
}

// Connection / program
let conn=new web3.Connection($('rpc').value,{commitment:'confirmed'});
let programId=new web3.PublicKey($('programId').value);
$('rpc').onchange=e=>conn=new web3.Connection(e.target.value,{commitment:'confirmed'});
$('programId').oninput=e=>{try{programId=new web3.PublicKey(e.target.value.trim())}catch{}};

$('ping').onclick=async()=>{try{$('rpcStatus').textContent='ok';log('RPC ok '+JSON.stringify(await conn.getVersion()));}catch(e){$('rpcStatus').textContent='error';log('Ping failed: '+e.message,false);}};

// Provider + wallet
const provider=()=> (window.phantom&&window.phantom.solana)?window.phantom.solana:((window.solana&&window.solana.isPhantom)?window.solana:null);
let wallet=null;

$('connect').onclick=async()=>{try{
  const p=provider(); if(!p) throw new Error('Phantom not detected');
  const r=await p.connect({onlyIfTrusted:false});
  wallet=new web3.PublicKey(r.publicKey.toString());
  $('wallet').innerHTML=exAddr(wallet.toBase58());
  const lam=await conn.getBalance(wallet);$('bal').textContent=(lam/1e9).toFixed(4)+' SOL';
  log('Connected '+wallet.toBase58());
}catch(e){log('Connect failed: '+e.message,false);}};

$('balance').onclick=async()=>{try{if(!wallet)throw new Error('Connect wallet first');const lam=await conn.getBalance(wallet);$('bal').textContent=(lam/1e9).toFixed(4)+' SOL';}catch(e){log('Balance failed: '+e.message,false);}};

$('airdrop').onclick=async()=>{try{if(!wallet)throw new Error('Connect wallet first');const sig=await conn.requestAirdrop(wallet,1e9);await conn.confirmTransaction(sig,'confirmed');log('Airdrop '+exTx(sig));await verifyOnChain(conn,sig);const lam=await conn.getBalance(wallet);$('bal').textContent=(lam/1e9).toFixed(4)+' SOL';}catch(e){log('Airdrop failed: '+e.message,false);}};

// Helpers: WebCrypto sha256 + small binary
const te=new TextEncoder();
const sha=async s=>new Uint8Array(await crypto.subtle.digest('SHA-256',te.encode(s)));
const u8=n=>Uint8Array.of(n&255);
const u32=n=>new Uint8Array([n&255,(n>>8)&255,(n>>16)&255,(n>>24)&255]);
const u64=n=>{let x=BigInt(n);const a=new Uint8Array(8);for(let i=0;i<8;i++){a[i]=Number(x&0xffn);x>>=8n;}return a;}
const cat=(...arr)=>{let L=0;for(const x of arr)L+=x.length;const out=new Uint8Array(L);let o=0;for(const x of arr){out.set(x,o);o+=x.length;}return out;}
const pkb=k=>new web3.PublicKey(k).toBytes();
const hex=s=>{const h=(s||'').replace(/^0x/,'');if(h.length%2)throw new Error('hex even');const out=new Uint8Array(h.length/2);for(let i=0;i<out.length;i++)out[i]=parseInt(h.slice(2*i,2*i+2),16);return out;}
const encMeta=m=>cat(pkb(m.pubkey),u8(m.isSigner?1:0),u8(m.isWritable?1:0));
const encVec=(items,enc)=>{const parts=items.map(enc);let L=0;for(const p of parts)L+=p.length;const buf=new Uint8Array(L);let o=0;for(const p of parts){buf.set(p,o);o+=p.length;}return cat(u32(items.length),buf);}
const vec=b=>cat(u32(b.length),b);
const disc=async n=>(await sha('global:'+n)).slice(0,8);

// Minimal ATA helpers
const ASSOCIATED_TOKEN_PROGRAM_ID=new web3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
const getAta=(mint,owner,tokenProgramId)=>web3.PublicKey.findProgramAddressSync([owner.toBytes(),tokenProgramId.toBytes(),mint.toBytes()],ASSOCIATED_TOKEN_PROGRAM_ID)[0];
const ataIx=(payer,ata,owner,mint,tokenProgramId)=>new web3.TransactionInstruction({
  programId:ASSOCIATED_TOKEN_PROGRAM_ID,
  keys:[
    {pubkey:payer,isSigner:true,isWritable:true},
    {pubkey:ata,isSigner:false,isWritable:true},
    {pubkey:owner,isSigner:false,isWritable:false},
    {pubkey:mint,isSigner:false,isWritable:false},
    {pubkey:web3.SystemProgram.programId,isSigner:false,isWritable:false},
    {pubkey:tokenProgramId,isSigner:false,isWritable:false},
  ],
  data:new Uint8Array([])
});

// PDAs (adjust to your seeds if different)
const poolPda=(mint,owner)=>web3.PublicKey.findProgramAddressSync([new TextEncoder().encode('pool'),mint.toBytes(),owner.toBytes()],programId)[0];
const vaultAuthPda=pool=>web3.PublicKey.findProgramAddressSync([new TextEncoder().encode('vault_auth'),pool.toBytes()],programId)[0];

let C={pool:null,vAuth:null,ata:null,tokenProg:null};

async function tokenProgForMint(m){const acc=await conn.getAccountInfo(m);if(!acc)throw new Error('Mint not found');$('whichTokenProg').textContent=acc.owner.toBase58();return acc.owner;}

$('derivePdas').onclick=async()=>{try{
  const p=provider();if(!p)throw new Error('Connect wallet first');
  const owner=new web3.PublicKey(p.publicKey.toString());
  const mint=new web3.PublicKey(($('mint').value||'').trim());
  const tp=await tokenProgForMint(mint);C.tokenProg=tp;
  const pool=poolPda(mint,owner); const vA=vaultAuthPda(pool); const ata=getAta(mint,vA,tp);
  C.pool=pool; C.vAuth=vA; C.ata=ata;
  $('poolPda').innerHTML=exAddr(pool.toBase58());
  $('vaultAuth').innerHTML=exAddr(vA.toBase58());
  $('vaultAta').innerHTML=exAddr(ata.toBase58());
  log('Derived PDAs');
}catch(e){log('derivePdas failed: '+e.message,false);}};

$('createVaultAta').onclick=async()=>{try{
  if(!wallet)throw new Error('Connect wallet first'); if(!C.ata)throw new Error('Derive PDAs first');
  const mint=new web3.PublicKey(($('mint').value||'').trim());
  const ix=ataIx(wallet,C.ata,C.vAuth,mint,C.tokenProg);
  const tx=new web3.Transaction().add(ix);
  const {blockhash,lastValidBlockHeight}=await conn.getLatestBlockhash(); tx.recentBlockhash=blockhash; tx.feePayer=wallet;
  const p=provider(); const signed=await p.signTransaction(tx);
  const sig=await conn.sendRawTransaction(signed.serialize(),{skipPreflight:false});
  await conn.confirmTransaction({signature:sig,blockhash,lastValidBlockHeight},'confirmed');
  log('Create Vault ATA: '+exTx(sig));
  await verifyOnChain(conn,sig);
}catch(e){if(String(e).includes('already in use'))log('Vault ATA already exists (ok).');else log('createVaultAta failed: '+e.message,false);}};

$('vaultBal').onclick=async()=>{try{
  if(!C.ata)throw new Error('Derive PDAs first');
  const info=await conn.getTokenAccountBalance(C.ata).catch(()=>null);
  $('vaultAmount').textContent=info?.value?.amount ?? '0';
}catch(e){log('vaultBal failed: '+e.message,false);}};

// EXECUTE ROUTE
$('execute').onclick=async()=>{try{
  if(!wallet)throw new Error('Connect wallet first');
  if(!C.pool||!C.vAuth||!C.ata)throw new Error('Derive PDAs first');

  const principal=BigInt(($('principal').value||'0').trim());
  let route=[]; try{route=JSON.parse(($('route').value||'[]').trim())}catch{throw new Error('Invalid JSON');}

  const encIx=ix=>{return (function(){
    const pid=new web3.PublicKey(ix.programId);
    const metas=(ix.metas||[]).map(m=>({pubkey:new web3.PublicKey(m.pubkey),isSigner:!!m.isSigner,isWritable:!!m.isWritable}));
    const data=hex(ix.data||'');
    return cat(pkb(pid), encVec(metas, m=>encMeta(m)), vec(data));
  })()};
  const routeBin=encVec(route, encIx);
  const data=cat(await disc('execute_route'), u64(principal), routeBin);

  const keys=[
    {pubkey:new web3.PublicKey(($('globalAddr').value||'').trim()),isSigner:false,isWritable:true},
    {pubkey:C.pool,isSigner:false,isWritable:true},
    {pubkey:C.vAuth,isSigner:false,isWritable:false},
    {pubkey:C.ata,isSigner:false,isWritable:true},
    {pubkey:wallet,isSigner:true,isWritable:true},
    {pubkey:C.tokenProg,isSigner:false,isWritable:false},
  ];
  const extra=new Set();
  for(const step of route){
    extra.add(new web3.PublicKey(step.programId).toBase58());
    for(const m of (step.metas||[])) extra.add(new web3.PublicKey(m.pubkey).toBase58());
  }
  for(const b58 of extra){ const pk=new web3.PublicKey(b58); if(!keys.find(k=>k.pubkey.equals(pk))) keys.push({pubkey:pk,isSigner:false,isWritable:false}); }

  const ix=new web3.TransactionInstruction({programId,keys,data});
  const tx=new web3.Transaction();
  const lim=parseInt($('cuLimit').value,10)||0; const price=parseInt($('cuPrice').value,10)||0;
  if(lim>0) tx.add(web3.ComputeBudgetProgram.setComputeUnitLimit({units:lim}));
  if(price>0) tx.add(web3.ComputeBudgetProgram.setComputeUnitPrice({microLamports:price}));
  tx.add(ix);

  const {blockhash,lastValidBlockHeight}=await conn.getLatestBlockhash(); tx.recentBlockhash=blockhash; tx.feePayer=wallet;
  const p=provider(); const signed=await p.signTransaction(tx);
  const sig=await conn.sendRawTransaction(signed.serialize(),{skipPreflight:false});
  await conn.confirmTransaction({signature:sig,blockhash,lastValidBlockHeight},'confirmed');
  log('Execute Route: '+exTx(sig));
  await verifyOnChain(conn,sig);
}catch(e){log('execute failed: '+e.message,false);}};

$('verifyDex').onclick=async()=>{try{
  const lines=$('dexList').value.split(/[\r\n]+/).map(s=>s.trim()).filter(Boolean); if(!lines.length){$('dexResults').textContent='No program IDs provided.';return;}
  const out=[]; for(const id of lines){try{const info=await conn.getAccountInfo(new web3.PublicKey(id)); if(!info){out.push(id+': NOT FOUND');continue;} out.push(`${id}: owner=${info.owner.toBase58()} executable=${info.executable} lamports=${info.lamports}`);}catch(e){out.push(`${id}: ERROR ${e.message}`);}}
  $('dexResults').innerText=out.join('\n');
}catch(e){$('dexResults').innerText='Verifier failed: '+e.message;}
})();
</script>
