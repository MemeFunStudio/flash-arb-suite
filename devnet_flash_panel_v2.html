<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Solana Devnet Control Panel — Flash Executor (LIVE, no mocks)</title>
  <style>
    :root{--bg:#0f1221;--card:#171a2e;--ink:#e8eaf6;--muted:#9aa3b2;--acc:#7aa2ff;--bad:#ff5d5d;--good:#36d399}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 ui-sans-serif,system-ui,Segoe UI,Roboto,Arial}
    .wrap{max-width:1100px;margin:0 auto;padding:24px}
    h1{font-size:24px;margin:0 0 10px}
    h2{font-size:18px;margin:24px 0 10px;color:var(--acc)}
    p, label{color:var(--muted)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:18px}
    .card{background:var(--card);border:1px solid #242845;border-radius:14px;padding:16px;box-shadow:0 1px 0 rgba(0,0,0,.2)}
    input, select, textarea, button{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #2b2f4a;background:#0d1022;color:var(--ink);outline:none}
    input::placeholder, textarea::placeholder{color:#6b7280}
    textarea{min-height:140px;resize:vertical}
    button{cursor:pointer;background:#1b2040;border-color:#2e3563}
    button:hover{background:#222750}
    .grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#0b0f24;border:1px solid #22284d;color:#c9d2f0;font-size:12px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    .ok{color:var(--good)} .bad{color:var(--bad)}
    .tx{border-left:3px solid #2f3563;padding-left:10px;margin:8px 0}
    .hint{font-size:12px;color:#96a0b8}
    .inline{display:flex;gap:8px;align-items:center}
    .small{font-size:12px}
    .kbd{background:#0e1230;border:1px solid #24306a;border-radius:6px;padding:1px 6px;font-size:12px}
    .hr{height:1px;background:#262a45;margin:14px 0}
    .badge{display:inline-block;background:#0e1332;border:1px solid #2d356f;border-radius:8px;padding:4px 8px;margin-right:6px;font-size:12px}
    .danger{background:#2a1020;border-color:#4a1640}
    .success{background:#0f2a20;border-color:#1c523f}
    .flex{display:flex;gap:10px;flex-wrap:wrap}
    .right{float:right}
    .muted{color:#9aa3b2}
    .mt8{margin-top:8px}
    .banner{margin-bottom:16px;padding:12px 14px;border-radius:12px;border:1px solid #3a3f6c;background:#121633}
  </style>
</head>
<body>
<div class="wrap">
  <h1>⚡ Flash Executor — Devnet Control Panel <span class="pill mono">LIVE • no mocks</span></h1>
  <div id="fileBanner" class="banner" style="display:none">
    <div class="small">
      You're opening this from <span class="mono">file://</span>. Chrome extensions (Phantom) are blocked on file URLs unless you enable
      <b>Allow access to file URLs</b> for the Phantom extension, or you serve this over <span class="mono">http://localhost</span>.<br/>
      Quick fix: go to <span class="kbd">chrome://extensions → Phantom → Details</span> and toggle <b>Allow access to file URLs</b>, then reload.
    </div>
  </div>
  <p class="hint">Program is derived from your <span class="mono">lib.rs</span>. All actions submit real transactions to Solana Devnet and link to Explorer.</p>

  <div class="card">
    <div class="row">
      <div>
        <label>RPC Cluster</label>
        <div class="inline">
          <select id="rpc">
            <option value="https://api.devnet.solana.com" selected>https://api.devnet.solana.com</option>
          </select>
          <button id="ping">Ping</button>
        </div>
        <div class="mt8 small">Status: <span id="rpcStatus" class="mono">—</span></div>
      </div>
      <div>
        <label>Program ID</label>
        <input id="programId" class="mono" value="9ckBy54vd9G6FmR63Z4PoLtNq8rbtoYzhVbJGx458Kmn"/>
        <div class="mt8 small">Loaded from your contract: <span class="mono">declare_id!(…)</span></div>
      </div>
    </div>
    <div class="hr"></div>
    <div class="row">
      <div>
        <button id="connect">Connect Phantom</button>
        <div class="mt8 small">Wallet: <span id="wallet" class="mono">—</span></div>
        <div id="connectHelp" class="mt8 small"></div>
      </div>
      <div>
        <div class="inline">
          <button id="airdrop">Airdrop 1 SOL</button>
          <button id="balance">Refresh Balance</button>
        </div>
        <div class="mt8 small">Balance: <span id="bal" class="mono">—</span></div>
      </div>
    </div>
  </div>

  <h2>1) Global Config</h2>
  <div class="card">
    <div class="row">
      <div>
        <label>Existing Global Account (optional)</label>
        <input id="globalAddr" placeholder="If already created, paste address. Otherwise create new below." class="mono"/>
        <div class="inline mt8">
          <button id="fetchGlobal">Fetch</button>
          <button id="downloadGlobal">Download Global Keypair</button>
        </div>
        <div class="mt8 small">Owner (from Global): <span id="globalOwner" class="mono">—</span></div>
      </div>
      <div>
        <label>Create New Global</label>
        <div class="inline">
          <button id="createGlobal">Generate Keypair</button>
          <button id="initGlobal">Initialize On-Chain</button>
        </div>
        <div class="mt8 small">New Global Addr: <span id="newGlobalAddr" class="mono">—</span></div>
      </div>
    </div>
    <div class="hr"></div>
    <div class="row">
      <div>
        <label>Add/Remove Executor</label>
        <input id="execKey" placeholder="Executor pubkey" class="mono"/>
        <div class="inline mt8">
          <button id="addExec">Add</button><button id="removeExec">Remove</button>
        </div>
      </div>
      <div>
        <label>Add/Remove DEX Program Whitelist</label>
        <input id="dexProg" placeholder="DEX program id (e.g. Raydium/Orca devnet pid)" class="mono"/>
        <div class="inline mt8">
          <button id="addDex">Add</button><button id="removeDex">Remove</button>
        </div>
      </div>
    </div>
  </div>

  <h2>2) Pool & Vault</h2>
  <div class="card">
    <div class="row">
      <div>
        <label>Mint Address</label>
        <input id="mint" placeholder="Token mint (devnet)" class="mono"/>
        <div class="mt8 small">Token Program: <span id="whichTokenProg" class="mono">—</span></div>
      </div>
      <div>
        <label>Pool Params</label>
        <div class="grid-3">
          <div><input id="minBps" type="number" value="30"/><div class="hint">min_profit_bps</div></div>
          <div><input id="poolEnabled" type="checkbox" checked/> <span>enabled</span></div>
          <div><button id="derivePdas">Derive PDAs</button></div>
        </div>
        <div class="mt8 small">Pool PDA: <span id="poolPda" class="mono">—</span></div>
        <div class="mt8 small">Vault Authority PDA: <span id="vaultAuth" class="mono">—</span></div>
        <div class="mt8 small">Vault ATA: <span id="vaultAta" class="mono">—</span></div>
      </div>
    </div>
    <div class="hr"></div>
    <div class="row">
      <div>
        <label>Vault</label>
        <div class="inline">
          <button id="createVaultAta">Create Vault ATA</button>
          <button id="vaultBal">Vault Balance</button>
        </div>
        <div class="mt8 small">Vault Amount: <span id="vaultAmount" class="mono">—</span></div>
      </div>
      <div>
        <label>Create / Update Pool</label>
        <div class="inline">
          <button id="createPool">Create Pool</button>
          <button id="setPool">Set Params</button>
        </div>
      </div>
    </div>
  </div>

  <h2>3) Execute Route (CPI path across whitelisted DEXes)</h2>
  <div class="card">
    <div class="row">
      <div>
        <label>Principal (u64, token base units)</label>
        <input id="principal" value="1000000" class="mono"/>
        <div class="mt8 hint">This is the starting vault balance portion being used as the notional principal for profit check.</div>
      </div>
      <div>
        <label>Compute Budget (optional)</label>
        <div class="grid-3">
          <div><input id="cuLimit" type="number" value="1200000"/><div class="hint">units</div></div>
          <div><input id="cuPrice" type="number" value="0"/><div class="hint">microlamports</div></div>
          <div><button id="execute">Execute Route</button></div>
        </div>
      </div>
    </div>
    <div class="hr"></div>
    <label>Route JSON</label>
    <textarea id="route" class="mono" placeholder='[
  {
    "programId": "DEX_PROGRAM_ID",
    "metas": [
      {"pubkey":"...","isSigner":false,"isWritable":true},
      {"pubkey":"...","isSigner":false,"isWritable":false}
    ],
    "data": "hex-encoded-cpi-data"
  }
]'></textarea>
    <div class="hint">Each step must target a whitelisted DEX program. Include every account the DEX needs. If the DEX needs the vault authority to sign, set the corresponding meta { pubkey: &lt;vaultAuth&gt;, isSigner: true } and the program will PDA-sign.</div>
  </div>

  <h2>4) DEX Program Verifier (Devnet)</h2>
  <div class="card">
    <label>Paste program IDs (one per line)</label>
    <textarea id="dexList" class="mono" placeholder="whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc
675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8"></textarea>
    <div class="inline mt8">
      <button id="verifyDex">Verify on-chain</button>
    </div>
    <div class="mt8 small">Results: <span id="dexResults" class="mono">—</span></div>
  </div>

  <h2>TX Log</h2>
  <div class="card" id="log"></div>

</div>

<script type="module">
import * as web3 from 'https://cdn.jsdelivr.net/npm/@solana/web3.js@1.95.3/+esm';
import { getAssociatedTokenAddress, createAssociatedTokenAccountInstruction, ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID } from 'https://cdn.jsdelivr.net/npm/@solana/spl-token@0.4.7/+esm';
import { sha256 } from 'https://cdn.jsdelivr.net/npm/js-sha256@0.9.0/+esm';

// ---------- file:// banner ----------
if (location.protocol === 'file:') {
  const b = document.getElementById('fileBanner');
  if (b) b.style.display = 'block';
}

// ---------- DOM helpers ----------
const $ = (id) => document.getElementById(id);
const logDiv = $('log');
function log(msg, ok=true) {
  const el = document.createElement('div');
  el.className = 'tx';
  el.innerHTML = ok ? msg : '<span class="bad">'+msg+'</span>';
  logDiv.prepend(el);
}
function exLink(sig){ 
  return `<a class="mono" target="_blank" href="https://explorer.solana.com/tx/${sig}?cluster=devnet">${sig}</a>`;
}
function addrLink(pk){ 
  return `<a class="mono" target="_blank" href="https://explorer.solana.com/address/${pk}?cluster=devnet">${pk}</a>`;
}

// ---------- Connection & Wallet ----------
let conn = new web3.Connection($('rpc').value, { commitment: 'confirmed' });
let wallet = null; // Phantom
let walletPubkey = null;
let programId = new web3.PublicKey($('programId').value);

// Provider detection helper
function getPhantom(){
  return (window.phantom && window.phantom.solana) ? window.phantom.solana :
         (window.solana && window.solana.isPhantom ? window.solana : null);
}

$('rpc').addEventListener('change', () => {
  conn = new web3.Connection($('rpc').value, { commitment: 'confirmed' });
  log('RPC changed.');
});

$('ping').onclick = async () => {
  try{
    const v = await conn.getVersion();
    $('rpcStatus').textContent = 'ok ' + JSON.stringify(v);
  }catch(e){ $('rpcStatus').textContent = 'error'; log('RPC error: '+e.message, false); }
};

$('connect').onclick = async () => {
  try{
    const provider = getPhantom();
    if (!provider) {
      $('connectHelp').innerHTML = `Phantom not detected. If you're opening this file directly, enable <b>Allow access to file URLs</b> for Phantom (chrome://extensions → Phantom → Details), or serve this over http://localhost.`;
      throw new Error('Phantom provider not found');
    }
    const res = await provider.connect({ onlyIfTrusted: false });
    wallet = provider;
    walletPubkey = new web3.PublicKey(res.publicKey.toString());
    $('wallet').innerHTML = addrLink(walletPubkey.toBase58());
    await refreshBal();
    log('Wallet connected.');
  }catch(e){ log('Connect failed: '+e.message, false); }
};

$('balance').onclick = refreshBal;
async function refreshBal(){
  if(!walletPubkey) return;
  const lam = await conn.getBalance(walletPubkey);
  $('bal').textContent = (lam/1e9).toFixed(4)+' SOL';
}

$('airdrop').onclick = async () => {
  try{
    if(!walletPubkey) throw new Error('Connect wallet first');
    const sig = await conn.requestAirdrop(walletPubkey, 1e9);
    await conn.confirmTransaction(sig, 'confirmed');
    await refreshBal();
    log('Airdrop tx: '+exLink(sig));
  }catch(e){ log('Airdrop failed: '+e.message, false); }
};

$('programId').addEventListener('input', (e)=>{
  try{ programId = new web3.PublicKey(e.target.value.trim()); }catch{}
});

// ---------- Discriminators & Borsh-ish encoding (Anchor-compatible) ----------
function disc(name){
  const preimage = 'global:'+name;
  const hashHex = sha256.array(preimage);
  return Uint8Array.from(hashHex.slice(0,8));
}
function u8(n){ return Uint8Array.of(n & 0xff); }
function u16le(n){ return new Uint8Array([n & 255, (n>>8) & 255]); }
function u32le(n){ return new Uint8Array([n & 255, (n>>8)&255, (n>>16)&255, (n>>24)&255]); }
function u64le(n){
  const b = BigInt(n);
  const a = new Uint8Array(8);
  let x = b;
  for(let i=0;i<8;i++){ a[i] = Number(x & 0xffn); x >>= 8n; }
  return a;
}
function pkBytes(pubkey){ return new web3.PublicKey(pubkey).toBytes(); }
function concat(...arrs){
  let total = 0; for(const a of arrs) total += a.length;
  const out = new Uint8Array(total);
  let off = 0;
  for(const a of arrs){ out.set(a, off); off += a.length; }
  return out;
}
function vecU8(bytes){ return concat(u32le(bytes.length), bytes); }

function encodeWireMeta(m){ return concat(pkBytes(m.pubkey), u8(m.isSigner?1:0), u8(m.isWritable?1:0)); }
function encodeVec(items, encFn){
  const parts = items.map(encFn);
  const totalLen = parts.reduce((s, x)=>s+x.length, 0);
  const out = new Uint8Array(totalLen);
  let off = 0; for(const p of parts){ out.set(p, off); off += p.length; }
  return concat(u32le(items.length), out);
}
function hexToBytes(hex){
  const s = (hex||'').replace(/^0x/,'').trim();
  if(s.length===0) return new Uint8Array();
  if(s.length%2!==0) throw new Error('hex length must be even');
  const out = new Uint8Array(s.length/2);
  for(let i=0;i<out.length;i++){ out[i]=parseInt(s.slice(2*i,2*i+2),16); }
  return out;
}
function encodeSerIx(ix){
  const metas = encodeVec(ix.metas || [], encodeWireMeta);
  const dataBytes = hexToBytes(ix.data || '');
  return concat(pkBytes(ix.programId), metas, vecU8(dataBytes));
}
function encodeRoute(route){ return encodeVec(route, encodeSerIx); }

// ---------- PDA helpers ----------
async function getTokenProgramForMint(mintPk){
  const acc = await conn.getAccountInfo(mintPk);
  if(!acc) throw new Error('Mint not found');
  const owner = acc.owner.toBase58();
  if(owner === TOKEN_2022_PROGRAM_ID.toBase58()){
    $('whichTokenProg').textContent = 'Token-2022';
    return TOKEN_2022_PROGRAM_ID;
  }else{
    $('whichTokenProg').textContent = 'Token (legacy)';
    return TOKEN_PROGRAM_ID;
  }
}
function derivePoolPda(mintPk, ownerPk){
  const [pda] = web3.PublicKey.findProgramAddressSync(
    [Buffer.from('pool'), mintPk.toBytes(), ownerPk.toBytes()],
    programId
  );
  return pda;
}
function deriveVaultAuthPda(poolPda){
  const [pda,_bump] = web3.PublicKey.findProgramAddressSync(
    [Buffer.from('vault_auth'), poolPda.toBytes()],
    programId
  );
  return pda;
}

// ---------- GLOBAL: create/init/fetch ----------
let globalKp = null;

$('createGlobal').onclick = () => {
  globalKp = web3.Keypair.generate();
  $('newGlobalAddr').textContent = globalKp.publicKey.toBase58();
  $('globalAddr').value = globalKp.publicKey.toBase58();
  log('Generated new Global keypair: '+addrLink(globalKp.publicKey.toBase58()));
};
$('downloadGlobal').onclick = () => {
  if(!globalKp){ log('Generate the Global keypair first.', false); return; }
  const blob = new Blob([JSON.stringify(Array.from(globalKp.secretKey))], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'global-keypair.json';
  a.click(); URL.revokeObjectURL(url);
  log('Downloaded global-keypair.json');
};
$('initGlobal').onclick = async () => {
  try{
    const provider = getPhantom();
    if(!provider) throw new Error('Phantom not detected');
    if(!globalKp) throw new Error('Generate Global keypair first');
    const owner = new web3.PublicKey(provider.publicKey.toString());
    const data = concat(disc('initialize_global'), owner.toBytes());
    const keys = [
      { pubkey: globalKp.publicKey, isSigner: true, isWritable: true },
      { pubkey: owner, isSigner: true, isWritable: true }, // payer
      { pubkey: web3.SystemProgram.programId, isSigner: false, isWritable: false },
    ];
    const ix = new web3.TransactionInstruction({ programId, keys, data });
    const tx = new web3.Transaction().add(ix);
    const { blockhash, lastValidBlockHeight } = await conn.getLatestBlockhash();
    tx.recentBlockhash = blockhash;
    tx.feePayer = owner;
    tx.partialSign(globalKp);
    const signed = await provider.signTransaction(tx);
    const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight:false });
    await conn.confirmTransaction({ signature:sig, blockhash, lastValidBlockHeight }, 'confirmed');
    log('Initialize Global: '+exLink(sig));
  }catch(e){ log('initGlobal failed: '+e.message, false); }
};

$('fetchGlobal').onclick = async () => {
  try{
    const g = new web3.PublicKey($('globalAddr').value.trim());
    const info = await conn.getAccountInfo(g);
    if(!info){ log('Global not found.', false); return; }
    const data = info.data;
    const owner = new web3.PublicKey(data.slice(8, 40));
    $('globalOwner').innerHTML = addrLink(owner.toBase58());
    log('Fetched Global.');
  }catch(e){ log('fetchGlobal failed: '+e.message, false); }
};

async function ownerOnlyIx(name, argPk, enable){
  const provider = getPhantom();
  const g = new web3.PublicKey($('globalAddr').value.trim());
  const data = concat(disc(name), argPk.toBytes(), new Uint8Array([enable?1:0]));
  const keys = [
    { pubkey: g, isSigner: false, isWritable: true },
    { pubkey: new web3.PublicKey(provider.publicKey.toString()), isSigner: true, isWritable: true },
  ];
  return new web3.TransactionInstruction({ programId, keys, data });
}

$('addExec').onclick = async ()=>{
  try{
    const ix = await ownerOnlyIx('set_executor', new web3.PublicKey($('execKey').value.trim()), true);
    const sig = await sendIx(ix);
    log('Add Executor: '+exLink(sig));
  }catch(e){ log('addExec failed: '+e.message, false); }
};
$('removeExec').onclick = async ()=>{
  try{
    const ix = await ownerOnlyIx('set_executor', new web3.PublicKey($('execKey').value.trim()), false);
    const sig = await sendIx(ix);
    log('Remove Executor: '+exLink(sig));
  }catch(e){ log('removeExec failed: '+e.message, false); }
};
$('addDex').onclick = async ()=>{
  try{
    const ix = await ownerOnlyIx('set_whitelist', new web3.PublicKey($('dexProg').value.trim()), true);
    const sig = await sendIx(ix);
    log('Add DEX whitelist: '+exLink(sig));
  }catch(e){ log('addDex failed: '+e.message, false); }
};
$('removeDex').onclick = async ()=>{
  try{
    const ix = await ownerOnlyIx('set_whitelist', new web3.PublicKey($('dexProg').value.trim()), false);
    const sig = await sendIx(ix);
    log('Remove DEX whitelist: '+exLink(sig));
  }catch(e){ log('removeDex failed: '+e.message, false); }
};

async function sendIx(ix, extraSigners=[]){
  const provider = getPhantom();
  if(!provider) throw new Error('Phantom not detected');
  const feePayer = new web3.PublicKey(provider.publicKey.toString());
  const tx = new web3.Transaction().add(ix);
  const { blockhash, lastValidBlockHeight } = await conn.getLatestBlockhash();
  tx.recentBlockhash = blockhash;
  tx.feePayer = feePayer;
  if(extraSigners.length) tx.partialSign(...extraSigners);
  const signed = await provider.signTransaction(tx);
  const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight:false });
  await conn.confirmTransaction({ signature:sig, blockhash, lastValidBlockHeight }, 'confirmed');
  return sig;
}

// ---------- POOL / VAULT ----------
let cached = { poolPda:null, vaultAuth:null, vaultAta:null, tokenProgramId:null };

$('derivePdas').onclick = async ()=>{
  try{
    const provider = getPhantom();
    const owner = new web3.PublicKey(provider.publicKey.toString());
    const mint = new web3.PublicKey($('mint').value.trim());
    const tokenProg = await getTokenProgramForMint(mint);
    cached.tokenProgramId = tokenProg;
    const pool = derivePoolPda(mint, owner);
    const vAuth = deriveVaultAuthPda(pool);
    const ata = await getAssociatedTokenAddress(mint, vAuth, true, tokenProg, ASSOCIATED_TOKEN_PROGRAM_ID);
    cached.poolPda = pool; cached.vaultAuth = vAuth; cached.vaultAta = ata;
    $('poolPda').textContent = pool.toBase58();
    $('vaultAuth').textContent = vAuth.toBase58();
    $('vaultAta').textContent = ata.toBase58();
    log('Derived PDAs.');
  }catch(e){ log('derivePdas failed: '+e.message, false); }
};

$('createVaultAta').onclick = async ()=>{
  try{
    const provider = getPhantom();
    if(!cached.vaultAta) throw new Error('Derive PDAs first');
    const mint = new web3.PublicKey($('mint').value.trim());
    const feePayer = new web3.PublicKey(provider.publicKey.toString());
    const ix = createAssociatedTokenAccountInstruction(
      feePayer, cached.vaultAta, cached.vaultAuth, mint,
      ASSOCIATED_TOKEN_PROGRAM_ID, cached.tokenProgramId
    );
    const sig = await sendIx(ix);
    log('Create Vault ATA: '+exLink(sig));
  }catch(e){
    if(String(e).includes('already in use')){
      log('Vault ATA already exists (ok).');
    } else {
      log('createVaultAta failed: '+e.message, false);
    }
  }
};

$('vaultBal').onclick = async ()=>{
  try{
    if(!cached.vaultAta) throw new Error('Derive PDAs first');
    const acc = await conn.getTokenAccountBalance(cached.vaultAta);
    $('vaultAmount').textContent = acc?.value?.amount ?? '0';
  }catch(e){ log('vaultBal failed: '+e.message, false); }
};

$('createPool').onclick = async ()=>{
  try{
    const provider = getPhantom();
    const g = new web3.PublicKey($('globalAddr').value.trim());
    const owner = new web3.PublicKey(provider.publicKey.toString());
    const mint = new web3.PublicKey($('mint').value.trim());
    const minBps = parseInt($('minBps').value,10) || 0;
    if(!cached.poolPda || !cached.vaultAuth || !cached.vaultAta) throw new Error('Derive PDAs first');
    const data = concat(disc('create_pool'), u16le(minBps));
    const keys = [
      { pubkey: g, isSigner:false, isWritable:true },
      { pubkey: cached.poolPda, isSigner:false, isWritable:true },
      { pubkey: owner, isSigner:true, isWritable:true },
      { pubkey: mint, isSigner:false, isWritable:false },
      { pubkey: cached.vaultAuth, isSigner:false, isWritable:false },
      { pubkey: cached.vaultAta, isSigner:false, isWritable:true },
      { pubkey: cached.tokenProgramId, isSigner:false, isWritable:false },
      { pubkey: web3.SystemProgram.programId, isSigner:false, isWritable:false },
    ];
    const ix = new web3.TransactionInstruction({ programId, keys, data });
    const sig = await sendIx(ix);
    log('Create Pool: '+exLink(sig));
  }catch(e){ log('createPool failed: '+e.message, false); }
};

$('setPool').onclick = async ()=>{
  try{
    const g = new web3.PublicKey($('globalAddr').value.trim());
    const minBps = parseInt($('minBps').value,10) || 0;
    const enabled = $('poolEnabled').checked;
    if(!cached.poolPda) throw new Error('Derive PDAs first');
    const data = concat(disc('set_pool_params'), u16le(minBps), u8(enabled?1:0));
    const keys = [
      { pubkey: g, isSigner:false, isWritable:true },
      { pubkey: cached.poolPda, isSigner:false, isWritable:true },
      { pubkey: new web3.PublicKey(getPhantom().publicKey.toString()), isSigner:true, isWritable:true },
    ];
    const ix = new web3.TransactionInstruction({ programId, keys, data });
    const sig = await sendIx(ix);
    log('Set Pool Params: '+exLink(sig));
  }catch(e){ log('setPool failed: '+e.message, false); }
};

// ---------- EXECUTE ROUTE ----------
$('execute').onclick = async ()=>{
  try{
    if(!cached.poolPda || !cached.vaultAuth || !cached.vaultAta) throw new Error('Derive PDAs first');
    const principal = BigInt($('principal').value.trim());
    let route;
    try{ route = JSON.parse($('route').value.trim() || '[]'); }catch{ throw new Error('Invalid JSON'); }
    if(!Array.isArray(route)) throw new Error('Route must be an array');
    const concat = (a,b)=>{ const out=new Uint8Array(a.length+b.length); out.set(a,0); out.set(b,a.length); return out; };

    // helper re-imports
    function disc(name){
      const preimage = 'global:'+name;
      const hashHex = sha256.array(preimage);
      return Uint8Array.from(hashHex.slice(0,8));
    }
    function u32le(n){ return new Uint8Array([n & 255, (n>>8)&255, (n>>16)&255, (n>>24)&255]); }
    function u64le(n){
      const b = BigInt(n); const a = new Uint8Array(8); let x=b;
      for(let i=0;i<8;i++){ a[i]=Number(x & 0xffn); x >>= 8n; }
      return a;
    }
    function pkBytes(pubkey){ return new web3.PublicKey(pubkey).toBytes(); }
    function encodeWireMeta(m){ return new Uint8Array([...pkBytes(m.pubkey), m.isSigner?1:0, m.isWritable?1:0]); }
    function encodeVec(items, encFn){
      const parts = items.map(encFn);
      const totalLen = parts.reduce((s, x)=>s+x.length, 0);
      const buf = new Uint8Array(totalLen); let off=0;
      for(const p of parts){ buf.set(p, off); off += p.length; }
      return new Uint8Array([...u32le(items.length), ...buf]);
    }
    function hexToBytes(hex){
      const s = (hex||'').replace(/^0x/,'').trim();
      if(s.length===0) return new Uint8Array();
      if(s.length%2!==0) throw new Error('hex length must be even');
      const out = new Uint8Array(s.length/2);
      for(let i=0;i<out.length;i++){ out[i]=parseInt(s.slice(2*i,2*i+2),16); }
      return out;
    }
    function encodeSerIx(ix){
      const metas = encodeVec(ix.metas || [], encodeWireMeta);
      const dataBytes = hexToBytes(ix.data || '');
      const payload = new Uint8Array([...pkBytes(ix.programId), ...metas, ...new Uint8Array([...u32le(dataBytes.length), ...dataBytes])]);
      return payload;
    }
    function encodeRoute(route){ return encodeVec(route, encodeSerIx); }

    const data = new Uint8Array([...disc('execute_route'), ...u64le(principal), ...encodeRoute(route)]);
    const tokenProgramId = cached.tokenProgramId;
    const keys = [
      { pubkey: new web3.PublicKey($('globalAddr').value.trim()), isSigner:false, isWritable:true },
      { pubkey: cached.poolPda, isSigner:false, isWritable:true },
      { pubkey: cached.vaultAuth, isSigner:false, isWritable:false },
      { pubkey: cached.vaultAta, isSigner:false, isWritable:true },
      { pubkey: new web3.PublicKey(getPhantom().publicKey.toString()), isSigner:true, isWritable:true },
      { pubkey: tokenProgramId, isSigner:false, isWritable:false },
    ];
    const pushKey = (pk, isSigner=false, isWritable=false) => keys.push({ pubkey:new web3.PublicKey(pk), isSigner, isWritable });
    // duplicate canonical accounts again for remaining (program enforces)
    for(const k of keys.slice(0)) keys.push({ ...k });
    for(const step of route){
      pushKey(step.programId, false, false);
      for(const m of (step.metas||[])) pushKey(m.pubkey, !!m.isSigner, !!m.isWritable);
    }
    const lim = parseInt($('cuLimit').value,10)||0;
    const price = parseInt($('cuPrice').value,10)||0;
    const cuIx = [];
    if(lim>0){ cuIx.push(web3.ComputeBudgetProgram.setComputeUnitLimit({ units: lim })); }
    if(price>0){ cuIx.push(web3.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: price })); }
    const ix = new web3.TransactionInstruction({ programId, keys, data });
    const tx = new web3.Transaction();
    cuIx.forEach(x=>tx.add(x));
    tx.add(ix);
    const provider = getPhantom();
    const { blockhash, lastValidBlockHeight } = await conn.getLatestBlockhash();
    tx.recentBlockhash = blockhash;
    tx.feePayer = new web3.PublicKey(provider.publicKey.toString());
    const signed = await provider.signTransaction(tx);
    const sig = await conn.sendRawTransaction(signed.serialize(), { skipPreflight:false });
    await conn.confirmTransaction({ signature:sig, blockhash, lastValidBlockHeight }, 'confirmed');
    log('Execute Route: '+exLink(sig));
  }catch(e){ log('execute failed: '+e.message, false); }
};

// ---------- DEX Verifier ----------
$('verifyDex').onclick = async ()=>{
  try{
    const list = $('dexList').value.split(/[\r\n]+/).map(s=>s.trim()).filter(Boolean);
    if(list.length===0){ $('dexResults').textContent = 'No program IDs provided.'; return; }
    const results = [];
    for(const id of list){
      try{
        const info = await conn.getAccountInfo(new web3.PublicKey(id));
        if(!info){ results.push(`${id}: NOT FOUND`); continue; }
        results.push(`${id}: owner=${info.owner.toBase58()} executable=${info.executable} lamports=${info.lamports}`);
      }catch(e){
        results.push(`${id}: ERROR ${e.message}`);
      }
    }
    $('dexResults').innerText = results.join('\n');
  }catch(e){
    $('dexResults').innerText = 'Verifier failed: '+e.message;
  }
};

</script>
</body>
</html>
