/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@solana/web3.js@1.95.3/lib/index.browser.esm.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{ed25519 as t}from"/npm/@noble/curves@1.5.0/ed25519/+esm";import e from"/npm/bn.js@5.2.1/+esm";import r from"/npm/bs58@4.0.1/+esm";import{sha256 as n}from"/npm/@noble/hashes@1.4.0/sha256/+esm";import{serialize as s,deserialize as i,deserializeUnchecked as o}from"/npm/borsh@0.7.0/+esm";import*as a from"/npm/@solana/buffer-layout@4.0.1/+esm";import{blob as c}from"/npm/@solana/buffer-layout@4.0.1/+esm";import{toBufferLE as u,toBigIntLE as l}from"/npm/bigint-buffer@1.1.5/+esm";import{coerce as h,instance as d,string as g,tuple as p,literal as y,unknown as f,type as m,number as b,array as k,nullable as w,optional as S,boolean as I,record as A,union as v,create as _,any as P,assert as E}from"/npm/superstruct@2.0.2/+esm";import R from"/npm/jayson@4.1.1/lib/client/browser/+esm";import{CommonClient as T,WebSocket as B}from"/npm/rpc-websockets@9.0.2/+esm";import{keccak_256 as x}from"/npm/@noble/hashes@1.4.0/sha3/+esm";import{secp256k1 as C}from"/npm/@noble/curves@1.5.0/secp256k1/+esm";var L="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},z=[],W=[],O="undefined"!=typeof Uint8Array?Uint8Array:Array,K=!1;function N(){K=!0;for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",e=0;e<64;++e)z[e]=t[e],W[t.charCodeAt(e)]=e;W["-".charCodeAt(0)]=62,W["_".charCodeAt(0)]=63}function U(t,e,r){for(var n,s,i=[],o=e;o<r;o+=3)n=(t[o]<<16)+(t[o+1]<<8)+t[o+2],i.push(z[(s=n)>>18&63]+z[s>>12&63]+z[s>>6&63]+z[63&s]);return i.join("")}function q(t){var e;K||N();for(var r=t.length,n=r%3,s="",i=[],o=16383,a=0,c=r-n;a<c;a+=o)i.push(U(t,a,a+o>c?c:a+o));return 1===n?(e=t[r-1],s+=z[e>>2],s+=z[e<<4&63],s+="=="):2===n&&(e=(t[r-2]<<8)+t[r-1],s+=z[e>>10],s+=z[e>>4&63],s+=z[e<<2&63],s+="="),i.push(s),i.join("")}function M(t,e,r,n,s){var i,o,a=8*s-n-1,c=(1<<a)-1,u=c>>1,l=-7,h=r?s-1:0,d=r?-1:1,g=t[e+h];for(h+=d,i=g&(1<<-l)-1,g>>=-l,l+=a;l>0;i=256*i+t[e+h],h+=d,l-=8);for(o=i&(1<<-l)-1,i>>=-l,l+=n;l>0;o=256*o+t[e+h],h+=d,l-=8);if(0===i)i=1-u;else{if(i===c)return o?NaN:1/0*(g?-1:1);o+=Math.pow(2,n),i-=u}return(g?-1:1)*o*Math.pow(2,i-n)}function D(t,e,r,n,s,i){var o,a,c,u=8*i-s-1,l=(1<<u)-1,h=l>>1,d=23===s?Math.pow(2,-24)-Math.pow(2,-77):0,g=n?0:i-1,p=n?1:-1,y=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,o=l):(o=Math.floor(Math.log(e)/Math.LN2),e*(c=Math.pow(2,-o))<1&&(o--,c*=2),(e+=o+h>=1?d/c:d*Math.pow(2,1-h))*c>=2&&(o++,c/=2),o+h>=l?(a=0,o=l):o+h>=1?(a=(e*c-1)*Math.pow(2,s),o+=h):(a=e*Math.pow(2,h-1)*Math.pow(2,s),o=0));s>=8;t[r+g]=255&a,g+=p,a/=256,s-=8);for(o=o<<s|a,u+=s;u>0;t[r+g]=255&o,g+=p,o/=256,u-=8);t[r+g-p]|=128*y}var V={}.toString,$=Array.isArray||function(t){return"[object Array]"==V.call(t)};function F(){return j.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function H(t,e){if(F()<e)throw new RangeError("Invalid typed array length");return j.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=j.prototype:(null===t&&(t=new j(e)),t.length=e),t}function j(t,e,r){if(!(j.TYPED_ARRAY_SUPPORT||this instanceof j))return new j(t,e,r);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return G(this,t)}return Y(this,t,e,r)}function Y(t,e,r,n){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,r,n){if(e.byteLength,r<0||e.byteLength<r)throw new RangeError("'offset' is out of bounds");if(e.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");e=void 0===r&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,r):new Uint8Array(e,r,n);j.TYPED_ARRAY_SUPPORT?(t=e).__proto__=j.prototype:t=X(t,e);return t}(t,e,r,n):"string"==typeof e?function(t,e,r){"string"==typeof r&&""!==r||(r="utf8");if(!j.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|tt(e,r);t=H(t,n);var s=t.write(e,r);s!==n&&(t=t.slice(0,s));return t}(t,e,r):function(t,e){if(Q(e)){var r=0|Z(e.length);return 0===(t=H(t,r)).length||e.copy(t,0,0,r),t}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||(n=e.length)!=n?H(t,0):X(t,e);if("Buffer"===e.type&&$(e.data))return X(t,e.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function J(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function G(t,e){if(J(e),t=H(t,e<0?0:0|Z(e)),!j.TYPED_ARRAY_SUPPORT)for(var r=0;r<e;++r)t[r]=0;return t}function X(t,e){var r=e.length<0?0:0|Z(e.length);t=H(t,r);for(var n=0;n<r;n+=1)t[n]=255&e[n];return t}function Z(t){if(t>=F())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+F().toString(16)+" bytes");return 0|t}function Q(t){return!(null==t||!t._isBuffer)}function tt(t,e){if(Q(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var r=t.length;if(0===r)return 0;for(var n=!1;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return Et(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return Rt(t).length;default:if(n)return Et(t).length;e=(""+e).toLowerCase(),n=!0}}function et(t,e,r){var n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return ft(this,e,r);case"utf8":case"utf-8":return dt(this,e,r);case"ascii":return pt(this,e,r);case"latin1":case"binary":return yt(this,e,r);case"base64":return ht(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return mt(this,e,r);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function rt(t,e,r){var n=t[e];t[e]=t[r],t[r]=n}function nt(t,e,r,n,s){if(0===t.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=s?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(s)return-1;r=t.length-1}else if(r<0){if(!s)return-1;r=0}if("string"==typeof e&&(e=j.from(e,n)),Q(e))return 0===e.length?-1:st(t,e,r,n,s);if("number"==typeof e)return e&=255,j.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?s?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):st(t,[e],r,n,s);throw new TypeError("val must be string, number or Buffer")}function st(t,e,r,n,s){var i,o=1,a=t.length,c=e.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||e.length<2)return-1;o=2,a/=2,c/=2,r/=2}function u(t,e){return 1===o?t[e]:t.readUInt16BE(e*o)}if(s){var l=-1;for(i=r;i<a;i++)if(u(t,i)===u(e,-1===l?0:i-l)){if(-1===l&&(l=i),i-l+1===c)return l*o}else-1!==l&&(i-=i-l),l=-1}else for(r+c>a&&(r=a-c),i=r;i>=0;i--){for(var h=!0,d=0;d<c;d++)if(u(t,i+d)!==u(e,d)){h=!1;break}if(h)return i}return-1}function it(t,e,r,n){r=Number(r)||0;var s=t.length-r;n?(n=Number(n))>s&&(n=s):n=s;var i=e.length;if(i%2!=0)throw new TypeError("Invalid hex string");n>i/2&&(n=i/2);for(var o=0;o<n;++o){var a=parseInt(e.substr(2*o,2),16);if(isNaN(a))return o;t[r+o]=a}return o}function ot(t,e,r,n){return Tt(Et(e,t.length-r),t,r,n)}function at(t,e,r,n){return Tt(function(t){for(var e=[],r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,n)}function ct(t,e,r,n){return at(t,e,r,n)}function ut(t,e,r,n){return Tt(Rt(e),t,r,n)}function lt(t,e,r,n){return Tt(function(t,e){for(var r,n,s,i=[],o=0;o<t.length&&!((e-=2)<0);++o)n=(r=t.charCodeAt(o))>>8,s=r%256,i.push(s),i.push(n);return i}(e,t.length-r),t,r,n)}function ht(t,e,r){return 0===e&&r===t.length?q(t):q(t.slice(e,r))}function dt(t,e,r){r=Math.min(t.length,r);for(var n=[],s=e;s<r;){var i,o,a,c,u=t[s],l=null,h=u>239?4:u>223?3:u>191?2:1;if(s+h<=r)switch(h){case 1:u<128&&(l=u);break;case 2:128==(192&(i=t[s+1]))&&(c=(31&u)<<6|63&i)>127&&(l=c);break;case 3:i=t[s+1],o=t[s+2],128==(192&i)&&128==(192&o)&&(c=(15&u)<<12|(63&i)<<6|63&o)>2047&&(c<55296||c>57343)&&(l=c);break;case 4:i=t[s+1],o=t[s+2],a=t[s+3],128==(192&i)&&128==(192&o)&&128==(192&a)&&(c=(15&u)<<18|(63&i)<<12|(63&o)<<6|63&a)>65535&&c<1114112&&(l=c)}null===l?(l=65533,h=1):l>65535&&(l-=65536,n.push(l>>>10&1023|55296),l=56320|1023&l),n.push(l),s+=h}return function(t){var e=t.length;if(e<=gt)return String.fromCharCode.apply(String,t);var r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=gt));return r}(n)}j.TYPED_ARRAY_SUPPORT=void 0===L.TYPED_ARRAY_SUPPORT||L.TYPED_ARRAY_SUPPORT,F(),j.poolSize=8192,j._augment=function(t){return t.__proto__=j.prototype,t},j.from=function(t,e,r){return Y(null,t,e,r)},j.TYPED_ARRAY_SUPPORT&&(j.prototype.__proto__=Uint8Array.prototype,j.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&j[Symbol.species]),j.alloc=function(t,e,r){return function(t,e,r,n){return J(e),e<=0?H(t,e):void 0!==r?"string"==typeof n?H(t,e).fill(r,n):H(t,e).fill(r):H(t,e)}(null,t,e,r)},j.allocUnsafe=function(t){return G(null,t)},j.allocUnsafeSlow=function(t){return G(null,t)},j.isBuffer=function(t){return null!=t&&(!!t._isBuffer||Bt(t)||function(t){return"function"==typeof t.readFloatLE&&"function"==typeof t.slice&&Bt(t.slice(0,0))}(t))},j.compare=function(t,e){if(!Q(t)||!Q(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var r=t.length,n=e.length,s=0,i=Math.min(r,n);s<i;++s)if(t[s]!==e[s]){r=t[s],n=e[s];break}return r<n?-1:n<r?1:0},j.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},j.concat=function(t,e){if(!$(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return j.alloc(0);var r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var n=j.allocUnsafe(e),s=0;for(r=0;r<t.length;++r){var i=t[r];if(!Q(i))throw new TypeError('"list" argument must be an Array of Buffers');i.copy(n,s),s+=i.length}return n},j.byteLength=tt,j.prototype._isBuffer=!0,j.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)rt(this,e,e+1);return this},j.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)rt(this,e,e+3),rt(this,e+1,e+2);return this},j.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)rt(this,e,e+7),rt(this,e+1,e+6),rt(this,e+2,e+5),rt(this,e+3,e+4);return this},j.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?dt(this,0,t):et.apply(this,arguments)},j.prototype.equals=function(t){if(!Q(t))throw new TypeError("Argument must be a Buffer");return this===t||0===j.compare(this,t)},j.prototype.inspect=function(){var t="";return this.length>0&&(t=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(t+=" ... ")),"<Buffer "+t+">"},j.prototype.compare=function(t,e,r,n,s){if(!Q(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===n&&(n=0),void 0===s&&(s=this.length),e<0||r>t.length||n<0||s>this.length)throw new RangeError("out of range index");if(n>=s&&e>=r)return 0;if(n>=s)return-1;if(e>=r)return 1;if(this===t)return 0;for(var i=(s>>>=0)-(n>>>=0),o=(r>>>=0)-(e>>>=0),a=Math.min(i,o),c=this.slice(n,s),u=t.slice(e,r),l=0;l<a;++l)if(c[l]!==u[l]){i=c[l],o=u[l];break}return i<o?-1:o<i?1:0},j.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},j.prototype.indexOf=function(t,e,r){return nt(this,t,e,r,!0)},j.prototype.lastIndexOf=function(t,e,r){return nt(this,t,e,r,!1)},j.prototype.write=function(t,e,r,n){if(void 0===e)n="utf8",r=this.length,e=0;else if(void 0===r&&"string"==typeof e)n=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var s=this.length-e;if((void 0===r||r>s)&&(r=s),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var i=!1;;)switch(n){case"hex":return it(this,t,e,r);case"utf8":case"utf-8":return ot(this,t,e,r);case"ascii":return at(this,t,e,r);case"latin1":case"binary":return ct(this,t,e,r);case"base64":return ut(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return lt(this,t,e,r);default:if(i)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),i=!0}},j.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var gt=4096;function pt(t,e,r){var n="";r=Math.min(t.length,r);for(var s=e;s<r;++s)n+=String.fromCharCode(127&t[s]);return n}function yt(t,e,r){var n="";r=Math.min(t.length,r);for(var s=e;s<r;++s)n+=String.fromCharCode(t[s]);return n}function ft(t,e,r){var n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);for(var s="",i=e;i<r;++i)s+=Pt(t[i]);return s}function mt(t,e,r){for(var n=t.slice(e,r),s="",i=0;i<n.length;i+=2)s+=String.fromCharCode(n[i]+256*n[i+1]);return s}function bt(t,e,r){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function kt(t,e,r,n,s,i){if(!Q(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>s||e<i)throw new RangeError('"value" argument is out of bounds');if(r+n>t.length)throw new RangeError("Index out of range")}function wt(t,e,r,n){e<0&&(e=65535+e+1);for(var s=0,i=Math.min(t.length-r,2);s<i;++s)t[r+s]=(e&255<<8*(n?s:1-s))>>>8*(n?s:1-s)}function St(t,e,r,n){e<0&&(e=4294967295+e+1);for(var s=0,i=Math.min(t.length-r,4);s<i;++s)t[r+s]=e>>>8*(n?s:3-s)&255}function It(t,e,r,n,s,i){if(r+n>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function At(t,e,r,n,s){return s||It(t,0,r,4),D(t,e,r,n,23,4),r+4}function vt(t,e,r,n,s){return s||It(t,0,r,8),D(t,e,r,n,52,8),r+8}j.prototype.slice=function(t,e){var r,n=this.length;if((t=~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),(e=void 0===e?n:~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),e<t&&(e=t),j.TYPED_ARRAY_SUPPORT)(r=this.subarray(t,e)).__proto__=j.prototype;else{var s=e-t;r=new j(s,void 0);for(var i=0;i<s;++i)r[i]=this[i+t]}return r},j.prototype.readUIntLE=function(t,e,r){t|=0,e|=0,r||bt(t,e,this.length);for(var n=this[t],s=1,i=0;++i<e&&(s*=256);)n+=this[t+i]*s;return n},j.prototype.readUIntBE=function(t,e,r){t|=0,e|=0,r||bt(t,e,this.length);for(var n=this[t+--e],s=1;e>0&&(s*=256);)n+=this[t+--e]*s;return n},j.prototype.readUInt8=function(t,e){return e||bt(t,1,this.length),this[t]},j.prototype.readUInt16LE=function(t,e){return e||bt(t,2,this.length),this[t]|this[t+1]<<8},j.prototype.readUInt16BE=function(t,e){return e||bt(t,2,this.length),this[t]<<8|this[t+1]},j.prototype.readUInt32LE=function(t,e){return e||bt(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},j.prototype.readUInt32BE=function(t,e){return e||bt(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},j.prototype.readIntLE=function(t,e,r){t|=0,e|=0,r||bt(t,e,this.length);for(var n=this[t],s=1,i=0;++i<e&&(s*=256);)n+=this[t+i]*s;return n>=(s*=128)&&(n-=Math.pow(2,8*e)),n},j.prototype.readIntBE=function(t,e,r){t|=0,e|=0,r||bt(t,e,this.length);for(var n=e,s=1,i=this[t+--n];n>0&&(s*=256);)i+=this[t+--n]*s;return i>=(s*=128)&&(i-=Math.pow(2,8*e)),i},j.prototype.readInt8=function(t,e){return e||bt(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},j.prototype.readInt16LE=function(t,e){e||bt(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},j.prototype.readInt16BE=function(t,e){e||bt(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},j.prototype.readInt32LE=function(t,e){return e||bt(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},j.prototype.readInt32BE=function(t,e){return e||bt(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},j.prototype.readFloatLE=function(t,e){return e||bt(t,4,this.length),M(this,t,!0,23,4)},j.prototype.readFloatBE=function(t,e){return e||bt(t,4,this.length),M(this,t,!1,23,4)},j.prototype.readDoubleLE=function(t,e){return e||bt(t,8,this.length),M(this,t,!0,52,8)},j.prototype.readDoubleBE=function(t,e){return e||bt(t,8,this.length),M(this,t,!1,52,8)},j.prototype.writeUIntLE=function(t,e,r,n){(t=+t,e|=0,r|=0,n)||kt(this,t,e,r,Math.pow(2,8*r)-1,0);var s=1,i=0;for(this[e]=255&t;++i<r&&(s*=256);)this[e+i]=t/s&255;return e+r},j.prototype.writeUIntBE=function(t,e,r,n){(t=+t,e|=0,r|=0,n)||kt(this,t,e,r,Math.pow(2,8*r)-1,0);var s=r-1,i=1;for(this[e+s]=255&t;--s>=0&&(i*=256);)this[e+s]=t/i&255;return e+r},j.prototype.writeUInt8=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,1,255,0),j.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},j.prototype.writeUInt16LE=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,2,65535,0),j.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):wt(this,t,e,!0),e+2},j.prototype.writeUInt16BE=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,2,65535,0),j.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):wt(this,t,e,!1),e+2},j.prototype.writeUInt32LE=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,4,4294967295,0),j.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):St(this,t,e,!0),e+4},j.prototype.writeUInt32BE=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,4,4294967295,0),j.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):St(this,t,e,!1),e+4},j.prototype.writeIntLE=function(t,e,r,n){if(t=+t,e|=0,!n){var s=Math.pow(2,8*r-1);kt(this,t,e,r,s-1,-s)}var i=0,o=1,a=0;for(this[e]=255&t;++i<r&&(o*=256);)t<0&&0===a&&0!==this[e+i-1]&&(a=1),this[e+i]=(t/o|0)-a&255;return e+r},j.prototype.writeIntBE=function(t,e,r,n){if(t=+t,e|=0,!n){var s=Math.pow(2,8*r-1);kt(this,t,e,r,s-1,-s)}var i=r-1,o=1,a=0;for(this[e+i]=255&t;--i>=0&&(o*=256);)t<0&&0===a&&0!==this[e+i+1]&&(a=1),this[e+i]=(t/o|0)-a&255;return e+r},j.prototype.writeInt8=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,1,127,-128),j.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},j.prototype.writeInt16LE=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,2,32767,-32768),j.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):wt(this,t,e,!0),e+2},j.prototype.writeInt16BE=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,2,32767,-32768),j.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):wt(this,t,e,!1),e+2},j.prototype.writeInt32LE=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,4,2147483647,-2147483648),j.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):St(this,t,e,!0),e+4},j.prototype.writeInt32BE=function(t,e,r){return t=+t,e|=0,r||kt(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),j.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):St(this,t,e,!1),e+4},j.prototype.writeFloatLE=function(t,e,r){return At(this,t,e,!0,r)},j.prototype.writeFloatBE=function(t,e,r){return At(this,t,e,!1,r)},j.prototype.writeDoubleLE=function(t,e,r){return vt(this,t,e,!0,r)},j.prototype.writeDoubleBE=function(t,e,r){return vt(this,t,e,!1,r)},j.prototype.copy=function(t,e,r,n){if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);var s,i=n-r;if(this===t&&r<e&&e<n)for(s=i-1;s>=0;--s)t[s+e]=this[s+r];else if(i<1e3||!j.TYPED_ARRAY_SUPPORT)for(s=0;s<i;++s)t[s+e]=this[s+r];else Uint8Array.prototype.set.call(t,this.subarray(r,r+i),e);return i},j.prototype.fill=function(t,e,r,n){if("string"==typeof t){if("string"==typeof e?(n=e,e=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===t.length){var s=t.charCodeAt(0);s<256&&(t=s)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!j.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<r)throw new RangeError("Out of range index");if(r<=e)return this;var i;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),"number"==typeof t)for(i=e;i<r;++i)this[i]=t;else{var o=Q(t)?t:Et(new j(t,n).toString()),a=o.length;for(i=0;i<r-e;++i)this[i+e]=o[i%a]}return this};var _t=/[^+\/0-9A-Za-z-_]/g;function Pt(t){return t<16?"0"+t.toString(16):t.toString(16)}function Et(t,e){var r;e=e||1/0;for(var n=t.length,s=null,i=[],o=0;o<n;++o){if((r=t.charCodeAt(o))>55295&&r<57344){if(!s){if(r>56319){(e-=3)>-1&&i.push(239,191,189);continue}if(o+1===n){(e-=3)>-1&&i.push(239,191,189);continue}s=r;continue}if(r<56320){(e-=3)>-1&&i.push(239,191,189),s=r;continue}r=65536+(s-55296<<10|r-56320)}else s&&(e-=3)>-1&&i.push(239,191,189);if(s=null,r<128){if((e-=1)<0)break;i.push(r)}else if(r<2048){if((e-=2)<0)break;i.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;i.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return i}function Rt(t){return function(t){var e,r,n,s,i,o;K||N();var a=t.length;if(a%4>0)throw new Error("Invalid string. Length must be a multiple of 4");i="="===t[a-2]?2:"="===t[a-1]?1:0,o=new O(3*a/4-i),n=i>0?a-4:a;var c=0;for(e=0,r=0;e<n;e+=4,r+=3)s=W[t.charCodeAt(e)]<<18|W[t.charCodeAt(e+1)]<<12|W[t.charCodeAt(e+2)]<<6|W[t.charCodeAt(e+3)],o[c++]=s>>16&255,o[c++]=s>>8&255,o[c++]=255&s;return 2===i?(s=W[t.charCodeAt(e)]<<2|W[t.charCodeAt(e+1)]>>4,o[c++]=255&s):1===i&&(s=W[t.charCodeAt(e)]<<10|W[t.charCodeAt(e+1)]<<4|W[t.charCodeAt(e+2)]>>2,o[c++]=s>>8&255,o[c++]=255&s),o}(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}(t).replace(_t,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function Tt(t,e,r,n){for(var s=0;s<n&&!(s+r>=e.length||s>=t.length);++s)e[s+r]=t[s];return s}function Bt(t){return!!t.constructor&&"function"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}const xt=t.utils.randomPrivateKey,Ct=()=>{const e=t.utils.randomPrivateKey(),r=Lt(e),n=new Uint8Array(64);return n.set(e),n.set(r,32),{publicKey:r,secretKey:n}},Lt=t.getPublicKey;function zt(e){try{return t.ExtendedPoint.fromHex(e),!0}catch{return!1}}const Wt=(e,r)=>t.sign(e,r.slice(0,32)),Ot=t.verify,Kt=t=>j.isBuffer(t)?t:t instanceof Uint8Array?j.from(t.buffer,t.byteOffset,t.byteLength):j.from(t);class Nt{constructor(t){Object.assign(this,t)}encode(){return j.from(s(qt,this))}static decode(t){return i(qt,this,t)}static decodeUnchecked(t){return o(qt,this,t)}}class Ut extends Nt{constructor(t){if(super(t),this.enum="",1!==Object.keys(t).length)throw new Error("Enum can only take single value");Object.keys(t).map((t=>{this.enum=t}))}}const qt=new Map;var Mt;const Dt=32,Vt=32;let $t=1;class Ft extends Nt{constructor(t){if(super({}),this._bn=void 0,function(t){return void 0!==t._bn}(t))this._bn=t._bn;else{if("string"==typeof t){const n=r.decode(t);if(n.length!=Vt)throw new Error("Invalid public key input");this._bn=new e(n)}else this._bn=new e(t);if(this._bn.byteLength()>Vt)throw new Error("Invalid public key input")}}static unique(){const t=new Ft($t);return $t+=1,new Ft(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return r.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(j);if(t.length===Vt)return t;const e=j.alloc(32);return t.copy(e,32-t.length),e}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,r){const s=j.concat([t.toBuffer(),j.from(e),r.toBuffer()]),i=n(s);return new Ft(i)}static createProgramAddressSync(t,e){let r=j.alloc(0);t.forEach((function(t){if(t.length>32)throw new TypeError("Max seed length exceeded");r=j.concat([r,Kt(t)])})),r=j.concat([r,e.toBuffer(),j.from("ProgramDerivedAddress")]);const s=n(r);if(zt(s))throw new Error("Invalid seeds, address must fall off the curve");return new Ft(s)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let r,n=255;for(;0!=n;){try{const s=t.concat(j.from([n]));r=this.createProgramAddressSync(s,e)}catch(t){if(t instanceof TypeError)throw t;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){return zt(new Ft(t).toBytes())}}Mt=Ft,Ft.default=new Mt("11111111111111111111111111111111"),qt.set(Ft,{kind:"struct",fields:[["_bn","u256"]]});class Ht{constructor(t){if(this._publicKey=void 0,this._secretKey=void 0,t){const e=Kt(t);if(64!==t.length)throw new Error("bad secret key size");this._publicKey=e.slice(32,64),this._secretKey=e.slice(0,32)}else this._secretKey=Kt(xt()),this._publicKey=Kt(Lt(this._secretKey))}get publicKey(){return new Ft(this._publicKey)}get secretKey(){return j.concat([this._secretKey,this._publicKey],64)}}const jt=new Ft("BPFLoader1111111111111111111111111111111111"),Yt=1232,Jt=127,Gt=64;class Xt extends Error{constructor(t){super(`Signature ${t} has expired: block height exceeded.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Xt.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Zt extends Error{constructor(t,e){super(`Transaction was not confirmed in ${e.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Zt.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Qt extends Error{constructor(t){super(`Signature ${t} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Qt.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class te{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const e=new Map;this.keySegments().flat().forEach(((t,r)=>{e.set(t.toBase58(),r)}));const r=t=>{const r=e.get(t.toBase58());if(void 0===r)throw new Error("Encountered an unknown instruction account key during compilation");return r};return t.map((t=>({programIdIndex:r(t.programId),accountKeyIndexes:t.keys.map((t=>r(t.pubkey))),data:t.data})))}}const ee=(t="publicKey")=>a.blob(32,t),re=(t="signature")=>a.blob(64,t),ne=(t="string")=>{const e=a.struct([a.u32("length"),a.u32("lengthPadding"),a.blob(a.offset(a.u32(),-8),"chars")],t),r=e.decode.bind(e),n=e.encode.bind(e),s=e;return s.decode=(t,e)=>r(t,e).chars.toString(),s.encode=(t,e,r)=>{const s={chars:j.from(t,"utf8")};return n(s,e,r)},s.alloc=t=>a.u32().span+a.u32().span+j.from(t,"utf8").length,s};function se(t,e){const r=t=>{if(t.span>=0)return t.span;if("function"==typeof t.alloc)return t.alloc(e[t.property]);if("count"in t&&"elementLayout"in t){const n=e[t.property];if(Array.isArray(n))return n.length*r(t.elementLayout)}else if("fields"in t)return se({layout:t},e[t.property]);return 0};let n=0;return t.layout.fields.forEach((t=>{n+=r(t)})),n}function ie(t){let e=0,r=0;for(;;){let n=t.shift();if(e|=(127&n)<<7*r,r+=1,!(128&n))break}return e}function oe(t,e){let r=e;for(;;){let e=127&r;if(r>>=7,0==r){t.push(e);break}e|=128,t.push(e)}}function ae(t,e){if(!t)throw new Error(e||"Assertion failed")}class ce{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,n=t=>{const e=t.toBase58();let n=r.get(e);return void 0===n&&(n={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(e,n)),n},s=n(e);s.isSigner=!0,s.isWritable=!0;for(const e of t){n(e.programId).isInvoked=!0;for(const t of e.keys){const e=n(t.pubkey);e.isSigner||=t.isSigner,e.isWritable||=t.isWritable}}return new ce(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];ae(t.length<=256,"Max static account keys length exceeded");const e=t.filter((([,t])=>t.isSigner&&t.isWritable)),r=t.filter((([,t])=>t.isSigner&&!t.isWritable)),n=t.filter((([,t])=>!t.isSigner&&t.isWritable)),s=t.filter((([,t])=>!t.isSigner&&!t.isWritable)),i={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:s.length};{ae(e.length>0,"Expected at least one writable signer key");const[t]=e[0];ae(t===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}return[i,[...e.map((([t])=>new Ft(t))),...r.map((([t])=>new Ft(t))),...n.map((([t])=>new Ft(t))),...s.map((([t])=>new Ft(t)))]]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,(t=>!t.isSigner&&!t.isInvoked&&t.isWritable)),[n,s]=this.drainKeysFoundInLookupTable(t.state.addresses,(t=>!t.isSigner&&!t.isInvoked&&!t.isWritable));if(0!==e.length||0!==n.length)return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:n},{writable:r,readonly:s}]}drainKeysFoundInLookupTable(t,e){const r=new Array,n=new Array;for(const[s,i]of this.keyMetaMap.entries())if(e(i)){const e=new Ft(s),i=t.findIndex((t=>t.equals(e)));i>=0&&(ae(i<256,"Max lookup table index exceeded"),r.push(i),n.push(e),this.keyMetaMap.delete(s))}return[r,n]}}const ue="Reached end of buffer unexpectedly";function le(t){if(0===t.length)throw new Error(ue);return t.shift()}function he(t,...e){const[r]=e;if(2===e.length?r+(e[1]??0)>t.length:r>=t.length)throw new Error(ue);return t.splice(...e)}class de{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map((t=>new Ft(t))),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach((t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex])))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map((t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:r.decode(t.data)})))}get addressTableLookups(){return[]}getAccountKeys(){return new te(this.staticAccountKeys)}static compile(t){const e=ce.compile(t.instructions,t.payerKey),[n,s]=e.getMessageComponents(),i=new te(s).compileInstructions(t.instructions).map((t=>({programIdIndex:t.programIdIndex,accounts:t.accountKeyIndexes,data:r.encode(t.data)})));return new de({header:n,accountKeys:s,recentBlockhash:t.recentBlockhash,instructions:i})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){return t-e<this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts}return t<e-this.header.numReadonlySignedAccounts}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter(((t,e)=>!this.isProgramId(e)))}serialize(){const t=this.accountKeys.length;let e=[];oe(e,t);const n=this.instructions.map((t=>{const{accounts:e,programIdIndex:n}=t,s=Array.from(r.decode(t.data));let i=[];oe(i,e.length);let o=[];return oe(o,s.length),{programIdIndex:n,keyIndicesCount:j.from(i),keyIndices:e,dataLength:j.from(o),data:s}}));let s=[];oe(s,n.length);let i=j.alloc(Yt);j.from(s).copy(i);let o=s.length;n.forEach((t=>{const e=a.struct([a.u8("programIdIndex"),a.blob(t.keyIndicesCount.length,"keyIndicesCount"),a.seq(a.u8("keyIndex"),t.keyIndices.length,"keyIndices"),a.blob(t.dataLength.length,"dataLength"),a.seq(a.u8("userdatum"),t.data.length,"data")]).encode(t,i,o);o+=e})),i=i.slice(0,o);const c=a.struct([a.blob(1,"numRequiredSignatures"),a.blob(1,"numReadonlySignedAccounts"),a.blob(1,"numReadonlyUnsignedAccounts"),a.blob(e.length,"keyCount"),a.seq(ee("key"),t,"keys"),ee("recentBlockhash")]),u={numRequiredSignatures:j.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:j.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:j.from([this.header.numReadonlyUnsignedAccounts]),keyCount:j.from(e),keys:this.accountKeys.map((t=>Kt(t.toBytes()))),recentBlockhash:r.decode(this.recentBlockhash)};let l=j.alloc(2048);const h=c.encode(u,l);return i.copy(l,h),l.slice(0,h+i.length)}static from(t){let e=[...t];const n=le(e);if(n!==(n&Jt))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=le(e),i=le(e),o=ie(e);let a=[];for(let t=0;t<o;t++){const t=he(e,0,Vt);a.push(new Ft(j.from(t)))}const c=he(e,0,Vt),u=ie(e);let l=[];for(let t=0;t<u;t++){const t=le(e),n=he(e,0,ie(e)),s=he(e,0,ie(e)),i=r.encode(j.from(s));l.push({programIdIndex:t,accounts:n,data:i})}const h={header:{numRequiredSignatures:n,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:i},recentBlockhash:r.encode(j.from(c)),accountKeys:a,instructions:l};return new de(h)}}class ge{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new te(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(t>=r){const e=t-r,n=this.addressTableLookups.reduce(((t,e)=>t+e.writableIndexes.length),0);return e<n}if(t>=this.header.numRequiredSignatures){return t-e<r-e-this.header.numReadonlyUnsignedAccounts}return t<e-this.header.numReadonlySignedAccounts}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const r of this.addressTableLookups){const n=t.find((t=>t.key.equals(r.accountKey)));if(!n)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const t of r.writableIndexes){if(!(t<n.state.addresses.length))throw new Error(`Failed to find address for index ${t} in address lookup table ${r.accountKey.toBase58()}`);e.writable.push(n.state.addresses[t])}for(const t of r.readonlyIndexes){if(!(t<n.state.addresses.length))throw new Error(`Failed to find address for index ${t} in address lookup table ${r.accountKey.toBase58()}`);e.readonly.push(n.state.addresses[t])}}return e}static compile(t){const e=ce.compile(t.instructions,t.payerKey),r=new Array,n={writable:new Array,readonly:new Array},s=t.addressLookupTableAccounts||[];for(const t of s){const s=e.extractTableLookup(t);if(void 0!==s){const[t,{writable:e,readonly:i}]=s;r.push(t),n.writable.push(...e),n.readonly.push(...i)}}const[i,o]=e.getMessageComponents(),a=new te(o,n).compileInstructions(t.instructions);return new ge({header:i,staticAccountKeys:o,recentBlockhash:t.recentBlockhash,compiledInstructions:a,addressTableLookups:r})}serialize(){const t=Array();oe(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),n=Array();oe(n,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),i=Array();oe(i,this.addressTableLookups.length);const o=a.struct([a.u8("prefix"),a.struct([a.u8("numRequiredSignatures"),a.u8("numReadonlySignedAccounts"),a.u8("numReadonlyUnsignedAccounts")],"header"),a.blob(t.length,"staticAccountKeysLength"),a.seq(ee(),this.staticAccountKeys.length,"staticAccountKeys"),ee("recentBlockhash"),a.blob(n.length,"instructionsLength"),a.blob(e.length,"serializedInstructions"),a.blob(i.length,"addressTableLookupsLength"),a.blob(s.length,"serializedAddressTableLookups")]),c=new Uint8Array(Yt),u=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map((t=>t.toBytes())),recentBlockhash:r.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(i),serializedAddressTableLookups:s},c);return c.slice(0,u)}serializeInstructions(){let t=0;const e=new Uint8Array(Yt);for(const r of this.compiledInstructions){const n=Array();oe(n,r.accountKeyIndexes.length);const s=Array();oe(s,r.data.length);t+=a.struct([a.u8("programIdIndex"),a.blob(n.length,"encodedAccountKeyIndexesLength"),a.seq(a.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),a.blob(s.length,"encodedDataLength"),a.blob(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(n),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(s),data:r.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array(Yt);for(const r of this.addressTableLookups){const n=Array();oe(n,r.writableIndexes.length);const s=Array();oe(s,r.readonlyIndexes.length);t+=a.struct([ee("accountKey"),a.blob(n.length,"encodedWritableIndexesLength"),a.seq(a.u8(),r.writableIndexes.length,"writableIndexes"),a.blob(s.length,"encodedReadonlyIndexesLength"),a.seq(a.u8(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(n),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(s),readonlyIndexes:r.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const n=le(e),s=n&Jt;ae(n!==s,"Expected versioned message but received legacy message");ae(0===s,`Expected versioned message with version 0 but found version ${s}`);const i={numRequiredSignatures:le(e),numReadonlySignedAccounts:le(e),numReadonlyUnsignedAccounts:le(e)},o=[],a=ie(e);for(let t=0;t<a;t++)o.push(new Ft(he(e,0,Vt)));const c=r.encode(he(e,0,Vt)),u=ie(e),l=[];for(let t=0;t<u;t++){const t=le(e),r=he(e,0,ie(e)),n=ie(e),s=new Uint8Array(he(e,0,n));l.push({programIdIndex:t,accountKeyIndexes:r,data:s})}const h=ie(e),d=[];for(let t=0;t<h;t++){const t=new Ft(he(e,0,Vt)),r=he(e,0,ie(e)),n=he(e,0,ie(e));d.push({accountKey:t,writableIndexes:r,readonlyIndexes:n})}return new ge({header:i,staticAccountKeys:o,recentBlockhash:c,compiledInstructions:l,addressTableLookups:d})}}const pe={deserializeMessageVersion(t){const e=t[0],r=e&Jt;return r===e?"legacy":r},deserialize:t=>{const e=pe.deserializeMessageVersion(t);if("legacy"===e)return de.from(t);if(0===e)return ge.deserialize(t);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let ye=function(t){return t[t.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",t[t.PROCESSED=1]="PROCESSED",t[t.TIMED_OUT=2]="TIMED_OUT",t[t.NONCE_INVALID=3]="NONCE_INVALID",t}({});const fe=j.alloc(64).fill(0);class me{constructor(t){this.keys=void 0,this.programId=void 0,this.data=j.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map((({pubkey:t,isSigner:e,isWritable:r})=>({pubkey:t.toJSON(),isSigner:e,isWritable:r}))),programId:this.programId.toJSON(),data:[...this.data]}}}class be{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:r}=t;this.minNonceContextSlot=e,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:r}=t;this.recentBlockhash=e,this.lastValidBlockHeight=r}else{const{recentBlockhash:e,nonceInfo:r}=t;r&&(this.nonceInfo=r),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map((t=>t.toJSON())),signers:this.signatures.map((({publicKey:t})=>t.toJSON()))}}add(...t){if(0===t.length)throw new Error("No instructions");return t.forEach((t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new me(t))})),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e,n;if(this.nonceInfo?(t=this.nonceInfo.nonce,e=this.instructions[0]!=this.nonceInfo.nonceInstruction?[this.nonceInfo.nonceInstruction,...this.instructions]:this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");if(e.length<1&&console.warn("No instructions provided"),this.feePayer)n=this.feePayer;else{if(!(this.signatures.length>0&&this.signatures[0].publicKey))throw new Error("Transaction fee payer required");n=this.signatures[0].publicKey}for(let t=0;t<e.length;t++)if(void 0===e[t].programId)throw new Error(`Transaction instruction index ${t} has undefined program id`);const s=[],i=[];e.forEach((t=>{t.keys.forEach((t=>{i.push({...t})}));const e=t.programId.toString();s.includes(e)||s.push(e)})),s.forEach((t=>{i.push({pubkey:new Ft(t),isSigner:!1,isWritable:!1})}));const o=[];i.forEach((t=>{const e=t.pubkey.toString(),r=o.findIndex((t=>t.pubkey.toString()===e));r>-1?(o[r].isWritable=o[r].isWritable||t.isWritable,o[r].isSigner=o[r].isSigner||t.isSigner):o.push(t)})),o.sort((function(t,e){if(t.isSigner!==e.isSigner)return t.isSigner?-1:1;if(t.isWritable!==e.isWritable)return t.isWritable?-1:1;return t.pubkey.toBase58().localeCompare(e.pubkey.toBase58(),"en",{localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"})}));const a=o.findIndex((t=>t.pubkey.equals(n)));if(a>-1){const[t]=o.splice(a,1);t.isSigner=!0,t.isWritable=!0,o.unshift(t)}else o.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const t of this.signatures){const e=o.findIndex((e=>e.pubkey.equals(t.publicKey)));if(!(e>-1))throw new Error(`unknown signer: ${t.publicKey.toString()}`);o[e].isSigner||(o[e].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))}let c=0,u=0,l=0;const h=[],d=[];o.forEach((({pubkey:t,isSigner:e,isWritable:r})=>{e?(h.push(t.toString()),c+=1,r||(u+=1)):(d.push(t.toString()),r||(l+=1))}));const g=h.concat(d),p=e.map((t=>{const{data:e,programId:n}=t;return{programIdIndex:g.indexOf(n.toString()),accounts:t.keys.map((t=>g.indexOf(t.pubkey.toString()))),data:r.encode(e)}}));return p.forEach((t=>{ae(t.programIdIndex>=0),t.accounts.forEach((t=>ae(t>=0)))})),new de({header:{numRequiredSignatures:c,numReadonlySignedAccounts:u,numReadonlyUnsignedAccounts:l},accountKeys:g,recentBlockhash:t,instructions:p})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);if(this.signatures.length===e.length){if(this.signatures.every(((t,r)=>e[r].equals(t.publicKey))))return t}return this.signatures=e.map((t=>({signature:null,publicKey:t}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(0===t.length)throw new Error("No signers");const e=new Set;this.signatures=t.filter((t=>{const r=t.toString();return!e.has(r)&&(e.add(r),!0)})).map((t=>({signature:null,publicKey:t})))}sign(...t){if(0===t.length)throw new Error("No signers");const e=new Set,r=[];for(const n of t){const t=n.publicKey.toString();e.has(t)||(e.add(t),r.push(n))}this.signatures=r.map((t=>({signature:null,publicKey:t.publicKey})));const n=this._compile();this._partialSign(n,...r)}partialSign(...t){if(0===t.length)throw new Error("No signers");const e=new Set,r=[];for(const n of t){const t=n.publicKey.toString();e.has(t)||(e.add(t),r.push(n))}const n=this._compile();this._partialSign(n,...r)}_partialSign(t,...e){const r=t.serialize();e.forEach((t=>{const e=Wt(r,t.secretKey);this._addSignature(t.publicKey,Kt(e))}))}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){ae(64===e.length);const r=this.signatures.findIndex((e=>t.equals(e.publicKey)));if(r<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[r].signature=j.from(e)}verifySignatures(t=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const r={};for(const{signature:n,publicKey:s}of this.signatures)null===n?e&&(r.missing||=[]).push(s):Ot(n,t,s.toBytes())||(r.invalid||=[]).push(s);return r.invalid||r.missing?r:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),n=this.serializeMessage();if(r){const t=this._getMessageSignednessErrors(n,e);if(t){let e="Signature verification failed.";throw t.invalid&&(e+=`\nInvalid signature for public key${1===t.invalid.length?"":"(s)"} [\`${t.invalid.map((t=>t.toBase58())).join("`, `")}\`].`),t.missing&&(e+=`\nMissing signature for public key${1===t.missing.length?"":"(s)"} [\`${t.missing.map((t=>t.toBase58())).join("`, `")}\`].`),new Error(e)}}return this._serialize(n)}_serialize(t){const{signatures:e}=this,r=[];oe(r,e.length);const n=r.length+64*e.length+t.length,s=j.alloc(n);return ae(e.length<256),j.from(r).copy(s,0),e.forEach((({signature:t},e)=>{null!==t&&(ae(64===t.length,"signature has invalid length"),j.from(t).copy(s,r.length+64*e))})),t.copy(s,r.length+64*e.length),ae(s.length<=Yt,`Transaction too large: ${s.length} > 1232`),s}get keys(){return ae(1===this.instructions.length),this.instructions[0].keys.map((t=>t.pubkey))}get programId(){return ae(1===this.instructions.length),this.instructions[0].programId}get data(){return ae(1===this.instructions.length),this.instructions[0].data}static from(t){let e=[...t];const n=ie(e);let s=[];for(let t=0;t<n;t++){const t=he(e,0,64);s.push(r.encode(j.from(t)))}return be.populate(de.from(e),s)}static populate(t,e=[]){const n=new be;return n.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(n.feePayer=t.accountKeys[0]),e.forEach(((e,s)=>{const i={signature:e==r.encode(fe)?null:r.decode(e),publicKey:t.accountKeys[s]};n.signatures.push(i)})),t.instructions.forEach((e=>{const s=e.accounts.map((e=>{const r=t.accountKeys[e];return{pubkey:r,isSigner:n.signatures.some((t=>t.publicKey.toString()===r.toString()))||t.isAccountSigner(e),isWritable:t.isAccountWritable(e)}}));n.instructions.push(new me({keys:s,programId:t.accountKeys[e.programIdIndex],data:r.decode(e.data)}))})),n._message=t,n._json=n.toJSON(),n}}class ke{constructor(t){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=t.payerKey,this.instructions=t.instructions,this.recentBlockhash=t.recentBlockhash}static decompile(t,e){const{header:r,compiledInstructions:n,recentBlockhash:s}=t,{numRequiredSignatures:i,numReadonlySignedAccounts:o,numReadonlyUnsignedAccounts:a}=r,c=i-o;ae(c>0,"Message header is invalid");const u=t.staticAccountKeys.length-i-a;ae(u>=0,"Message header is invalid");const l=t.getAccountKeys(e),h=l.get(0);if(void 0===h)throw new Error("Failed to decompile message because no account keys were found");const d=[];for(const t of n){const e=[];for(const n of t.accountKeyIndexes){const t=l.get(n);if(void 0===t)throw new Error(`Failed to find key for account key index ${n}`);let s;s=n<i?n<c:n<l.staticAccountKeys.length?n-i<u:n-l.staticAccountKeys.length<l.accountKeysFromLookups.writable.length,e.push({pubkey:t,isSigner:n<r.numRequiredSignatures,isWritable:s})}const n=l.get(t.programIdIndex);if(void 0===n)throw new Error(`Failed to find program id for program id index ${t.programIdIndex}`);d.push(new me({programId:n,data:Kt(t.data),keys:e}))}return new ke({payerKey:h,instructions:d,recentBlockhash:s})}compileToLegacyMessage(){return de.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(t){return ge.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:t})}}class we{get version(){return this.message.version}constructor(t,e){if(this.signatures=void 0,this.message=void 0,void 0!==e)ae(e.length===t.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=e;else{const e=[];for(let r=0;r<t.header.numRequiredSignatures;r++)e.push(new Uint8Array(64));this.signatures=e}this.message=t}serialize(){const t=this.message.serialize(),e=Array();oe(e,this.signatures.length);const r=a.struct([a.blob(e.length,"encodedSignaturesLength"),a.seq(re(),this.signatures.length,"signatures"),a.blob(t.length,"serializedMessage")]),n=new Uint8Array(2048),s=r.encode({encodedSignaturesLength:new Uint8Array(e),signatures:this.signatures,serializedMessage:t},n);return n.slice(0,s)}static deserialize(t){let e=[...t];const r=[],n=ie(e);for(let t=0;t<n;t++)r.push(new Uint8Array(he(e,0,64)));const s=pe.deserialize(new Uint8Array(e));return new we(s,r)}sign(t){const e=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const n of t){const t=r.findIndex((t=>t.equals(n.publicKey)));ae(t>=0,`Cannot sign with non signer key ${n.publicKey.toBase58()}`),this.signatures[t]=Wt(e,n.secretKey)}}addSignature(t,e){ae(64===e.byteLength,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex((e=>e.equals(t)));ae(r>=0,`Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=e}}const Se=new Ft("SysvarC1ock11111111111111111111111111111111"),Ie=new Ft("SysvarEpochSchedu1e111111111111111111111111"),Ae=new Ft("Sysvar1nstructions1111111111111111111111111"),ve=new Ft("SysvarRecentB1ockHashes11111111111111111111"),_e=new Ft("SysvarRent111111111111111111111111111111111"),Pe=new Ft("SysvarRewards111111111111111111111111111111"),Ee=new Ft("SysvarS1otHashes111111111111111111111111111"),Re=new Ft("SysvarS1otHistory11111111111111111111111111"),Te=new Ft("SysvarStakeHistory1111111111111111111111111");class Be extends Error{constructor({action:t,signature:e,transactionMessage:r,logs:n}){const s=n?`Logs: \n${JSON.stringify(n.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let o;switch(t){case"send":o=`Transaction ${e} resulted in an error. \n${r}. `+s+i;break;case"simulate":o=`Simulation failed. \nMessage: ${r}. \n`+s+i;break;default:o=`Unknown action '${t}'`}super(o),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=e,this.transactionMessage=r,this.transactionLogs=n||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const t=this.transactionLogs;if(null==t||"object"!=typeof t||!("then"in t))return t}async getLogs(t){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise(((e,r)=>{t.getTransaction(this.signature).then((t=>{if(t&&t.meta&&t.meta.logMessages){const r=t.meta.logMessages;this.transactionLogs=r,e(r)}else r(new Error("Log messages not found"))})).catch(r)}))),await this.transactionLogs}}const xe={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class Ce extends Error{constructor({code:t,message:e,data:r},n){super(null!=n?`${n}: ${e}`:e),this.code=void 0,this.data=void 0,this.code=t,this.data=r,this.name="SolanaJSONRPCError"}}async function Le(t,e,r,n){const s=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},i=await t.sendTransaction(e,r,s);let o;if(null!=e.recentBlockhash&&null!=e.lastValidBlockHeight)o=(await t.confirmTransaction({abortSignal:n?.abortSignal,signature:i,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(null!=e.minNonceContextSlot&&null!=e.nonceInfo){const{nonceInstruction:r}=e.nonceInfo,s=r.keys[0].pubkey;o=(await t.confirmTransaction({abortSignal:n?.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:s,nonceValue:e.nonceInfo.nonce,signature:i},n&&n.commitment)).value}else null!=n?.abortSignal&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await t.confirmTransaction(i,n&&n.commitment)).value;if(o.err){if(null!=i)throw new Be({action:"send",signature:i,transactionMessage:`Status: (${JSON.stringify(o)})`});throw new Error(`Transaction ${i} failed (${JSON.stringify(o)})`)}return i}function ze(t){return new Promise((e=>setTimeout(e,t)))}function We(t,e){const r=t.layout.span>=0?t.layout.span:se(t,e),n=j.alloc(r),s=Object.assign({instruction:t.index},e);return t.layout.encode(s,n),n}function Oe(t,e){let r;try{r=t.layout.decode(e)}catch(t){throw new Error("invalid instruction; "+t)}if(r.instruction!==t.index)throw new Error(`invalid instruction; instruction index mismatch ${r.instruction} != ${t.index}`);return r}const Ke=a.nu64("lamportsPerSignature"),Ne=a.struct([a.u32("version"),a.u32("state"),ee("authorizedPubkey"),ee("nonce"),a.struct([Ke],"feeCalculator")]),Ue=Ne.span;class qe{constructor(t){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=t.authorizedPubkey,this.nonce=t.nonce,this.feeCalculator=t.feeCalculator}static fromAccountData(t){const e=Ne.decode(Kt(t),0);return new qe({authorizedPubkey:new Ft(e.authorizedPubkey),nonce:new Ft(e.nonce).toString(),feeCalculator:e.feeCalculator})}}const Me=(De=8,t=>{const e=c(De,t),{encode:r,decode:n}=(t=>({decode:t.decode.bind(t),encode:t.encode.bind(t)}))(e),s=e;return s.decode=(t,e)=>{const r=n(t,e);return l(j.from(r))},s.encode=(t,e,n)=>{const s=u(t,De);return r(s,e,n)},s});var De;class Ve{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const e=a.u32("instruction").decode(t.data);let r;for(const[t,n]of Object.entries($e))if(n.index==e){r=t;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{lamports:e,space:r,programId:n}=Oe($e.Create,t.data);return{fromPubkey:t.keys[0].pubkey,newAccountPubkey:t.keys[1].pubkey,lamports:e,space:r,programId:new Ft(n)}}static decodeTransfer(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{lamports:e}=Oe($e.Transfer,t.data);return{fromPubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,lamports:e}}static decodeTransferWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e,seed:r,programId:n}=Oe($e.TransferWithSeed,t.data);return{fromPubkey:t.keys[0].pubkey,basePubkey:t.keys[1].pubkey,toPubkey:t.keys[2].pubkey,lamports:e,seed:r,programId:new Ft(n)}}static decodeAllocate(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{space:e}=Oe($e.Allocate,t.data);return{accountPubkey:t.keys[0].pubkey,space:e}}static decodeAllocateWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{base:e,seed:r,space:n,programId:s}=Oe($e.AllocateWithSeed,t.data);return{accountPubkey:t.keys[0].pubkey,basePubkey:new Ft(e),seed:r,space:n,programId:new Ft(s)}}static decodeAssign(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{programId:e}=Oe($e.Assign,t.data);return{accountPubkey:t.keys[0].pubkey,programId:new Ft(e)}}static decodeAssignWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{base:e,seed:r,programId:n}=Oe($e.AssignWithSeed,t.data);return{accountPubkey:t.keys[0].pubkey,basePubkey:new Ft(e),seed:r,programId:new Ft(n)}}static decodeCreateWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{base:e,seed:r,lamports:n,space:s,programId:i}=Oe($e.CreateWithSeed,t.data);return{fromPubkey:t.keys[0].pubkey,newAccountPubkey:t.keys[1].pubkey,basePubkey:new Ft(e),seed:r,lamports:n,space:s,programId:new Ft(i)}}static decodeNonceInitialize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{authorized:e}=Oe($e.InitializeNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,authorizedPubkey:new Ft(e)}}static decodeNonceAdvance(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),Oe($e.AdvanceNonceAccount,t.data),{noncePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey}}static decodeNonceWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,5);const{lamports:e}=Oe($e.WithdrawNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey,lamports:e}}static decodeNonceAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{authorized:e}=Oe($e.AuthorizeNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[1].pubkey,newAuthorizedPubkey:new Ft(e)}}static checkProgramId(t){if(!t.equals(Fe.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const $e=Object.freeze({Create:{index:0,layout:a.struct([a.u32("instruction"),a.ns64("lamports"),a.ns64("space"),ee("programId")])},Assign:{index:1,layout:a.struct([a.u32("instruction"),ee("programId")])},Transfer:{index:2,layout:a.struct([a.u32("instruction"),Me("lamports")])},CreateWithSeed:{index:3,layout:a.struct([a.u32("instruction"),ee("base"),ne("seed"),a.ns64("lamports"),a.ns64("space"),ee("programId")])},AdvanceNonceAccount:{index:4,layout:a.struct([a.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:a.struct([a.u32("instruction"),a.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:a.struct([a.u32("instruction"),ee("authorized")])},AuthorizeNonceAccount:{index:7,layout:a.struct([a.u32("instruction"),ee("authorized")])},Allocate:{index:8,layout:a.struct([a.u32("instruction"),a.ns64("space")])},AllocateWithSeed:{index:9,layout:a.struct([a.u32("instruction"),ee("base"),ne("seed"),a.ns64("space"),ee("programId")])},AssignWithSeed:{index:10,layout:a.struct([a.u32("instruction"),ee("base"),ne("seed"),ee("programId")])},TransferWithSeed:{index:11,layout:a.struct([a.u32("instruction"),Me("lamports"),ne("seed"),ee("programId")])},UpgradeNonceAccount:{index:12,layout:a.struct([a.u32("instruction")])}});class Fe{constructor(){}static createAccount(t){const e=We($e.Create,{lamports:t.lamports,space:t.space,programId:Kt(t.programId.toBuffer())});return new me({keys:[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:e})}static transfer(t){let e,r;if("basePubkey"in t){e=We($e.TransferWithSeed,{lamports:BigInt(t.lamports),seed:t.seed,programId:Kt(t.programId.toBuffer())}),r=[{pubkey:t.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}else{e=We($e.Transfer,{lamports:BigInt(t.lamports)}),r=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}return new me({keys:r,programId:this.programId,data:e})}static assign(t){let e,r;if("basePubkey"in t){e=We($e.AssignWithSeed,{base:Kt(t.basePubkey.toBuffer()),seed:t.seed,programId:Kt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{e=We($e.Assign,{programId:Kt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new me({keys:r,programId:this.programId,data:e})}static createAccountWithSeed(t){const e=We($e.CreateWithSeed,{base:Kt(t.basePubkey.toBuffer()),seed:t.seed,lamports:t.lamports,space:t.space,programId:Kt(t.programId.toBuffer())});let r=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!1,isWritable:!0}];return t.basePubkey.equals(t.fromPubkey)||r.push({pubkey:t.basePubkey,isSigner:!0,isWritable:!1}),new me({keys:r,programId:this.programId,data:e})}static createNonceAccount(t){const e=new be;"basePubkey"in t&&"seed"in t?e.add(Fe.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:Ue,programId:this.programId})):e.add(Fe.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,lamports:t.lamports,space:Ue,programId:this.programId}));const r={noncePubkey:t.noncePubkey,authorizedPubkey:t.authorizedPubkey};return e.add(this.nonceInitialize(r)),e}static nonceInitialize(t){const e=We($e.InitializeNonceAccount,{authorized:Kt(t.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ve,isSigner:!1,isWritable:!1},{pubkey:_e,isSigner:!1,isWritable:!1}],programId:this.programId,data:e};return new me(r)}static nonceAdvance(t){const e=We($e.AdvanceNonceAccount),r={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ve,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:e};return new me(r)}static nonceWithdraw(t){const e=We($e.WithdrawNonceAccount,{lamports:t.lamports});return new me({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ve,isSigner:!1,isWritable:!1},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:e})}static nonceAuthorize(t){const e=We($e.AuthorizeNonceAccount,{authorized:Kt(t.newAuthorizedPubkey.toBuffer())});return new me({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:e})}static allocate(t){let e,r;if("basePubkey"in t){e=We($e.AllocateWithSeed,{base:Kt(t.basePubkey.toBuffer()),seed:t.seed,space:t.space,programId:Kt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{e=We($e.Allocate,{space:t.space}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new me({keys:r,programId:this.programId,data:e})}}Fe.programId=new Ft("11111111111111111111111111111111");class He{constructor(){}static getMinNumSignatures(t){return 2*(Math.ceil(t/He.chunkSize)+1+1)}static async load(t,e,r,n,s){{const i=await t.getMinimumBalanceForRentExemption(s.length),o=await t.getAccountInfo(r.publicKey,"confirmed");let a=null;if(null!==o){if(o.executable)return console.error("Program load failed, account is already executable"),!1;o.data.length!==s.length&&(a=a||new be,a.add(Fe.allocate({accountPubkey:r.publicKey,space:s.length}))),o.owner.equals(n)||(a=a||new be,a.add(Fe.assign({accountPubkey:r.publicKey,programId:n}))),o.lamports<i&&(a=a||new be,a.add(Fe.transfer({fromPubkey:e.publicKey,toPubkey:r.publicKey,lamports:i-o.lamports})))}else a=(new be).add(Fe.createAccount({fromPubkey:e.publicKey,newAccountPubkey:r.publicKey,lamports:i>0?i:1,space:s.length,programId:n}));null!==a&&await Le(t,a,[e,r],{commitment:"confirmed"})}const i=a.struct([a.u32("instruction"),a.u32("offset"),a.u32("bytesLength"),a.u32("bytesLengthPadding"),a.seq(a.u8("byte"),a.offset(a.u32(),-8),"bytes")]),o=He.chunkSize;let c=0,u=s,l=[];for(;u.length>0;){const s=u.slice(0,o),a=j.alloc(o+16);i.encode({instruction:0,offset:c,bytes:s,bytesLength:0,bytesLengthPadding:0},a);const h=(new be).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:n,data:a});if(l.push(Le(t,h,[e,r],{commitment:"confirmed"})),t._rpcEndpoint.includes("solana.com")){const t=4;await ze(1e3/t)}c+=o,u=u.slice(o)}await Promise.all(l);{const s=a.struct([a.u32("instruction")]),i=j.alloc(s.span);s.encode({instruction:1},i);const o=(new be).add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1}],programId:n,data:i}),c="processed",u=await t.sendTransaction(o,[e,r],{preflightCommitment:c}),{context:l,value:h}=await t.confirmTransaction({signature:u,lastValidBlockHeight:o.lastValidBlockHeight,blockhash:o.recentBlockhash},c);if(h.err)throw new Error(`Transaction ${u} failed (${JSON.stringify(h)})`);for(;;){try{if(await t.getSlot({commitment:c})>l.slot)break}catch{}await new Promise((t=>setTimeout(t,Math.round(200))))}}return!0}}He.chunkSize=932;const je=new Ft("BPFLoader2111111111111111111111111111111111");class Ye{static getMinNumSignatures(t){return He.getMinNumSignatures(t)}static load(t,e,r,n,s){return He.load(t,e,r,s,n)}}function Je(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var Ge=Object.prototype.toString,Xe=Object.keys||function(t){var e=[];for(var r in t)e.push(r);return e};function Ze(t,e){var r,n,s,i,o,a,c;if(!0===t)return"true";if(!1===t)return"false";switch(typeof t){case"object":if(null===t)return null;if(t.toJSON&&"function"==typeof t.toJSON)return Ze(t.toJSON(),e);if("[object Array]"===(c=Ge.call(t))){for(s="[",n=t.length-1,r=0;r<n;r++)s+=Ze(t[r],!0)+",";return n>-1&&(s+=Ze(t[r],!0)),s+"]"}if("[object Object]"===c){for(n=(i=Xe(t).sort()).length,s="",r=0;r<n;)void 0!==(a=Ze(t[o=i[r]],!1))&&(s&&(s+=","),s+=JSON.stringify(o)+":"+a),r++;return"{"+s+"}"}return JSON.stringify(t);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(t);default:return isFinite(t)?t:null}}var Qe=Je((function(t){var e=Ze(t,!1);if(void 0!==e)return""+e}));function tr(t){let e=0;for(;t>1;)t/=2,e++;return e}class er{constructor(t,e,r,n,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=t,this.leaderScheduleSlotOffset=e,this.warmup=r,this.firstNormalEpoch=n,this.firstNormalSlot=s}getEpoch(t){return this.getEpochAndSlotIndex(t)[0]}getEpochAndSlotIndex(t){if(t<this.firstNormalSlot){const r=tr(0===(e=t+32+1)?1:(e--,e|=e>>1,e|=e>>2,e|=e>>4,e|=e>>8,e|=e>>16,1+(e|=e>>32)))-tr(32)-1;return[r,t-(this.getSlotsInEpoch(r)-32)]}{const e=t-this.firstNormalSlot,r=Math.floor(e/this.slotsPerEpoch);return[this.firstNormalEpoch+r,e%this.slotsPerEpoch]}var e}getFirstSlotInEpoch(t){return t<=this.firstNormalEpoch?32*(Math.pow(2,t)-1):(t-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(t){return this.getFirstSlotInEpoch(t)+this.getSlotsInEpoch(t)-1}getSlotsInEpoch(t){return t<this.firstNormalEpoch?Math.pow(2,t+tr(32)):this.slotsPerEpoch}}var rr=globalThis.fetch;class nr extends T{constructor(t,e,r){super((t=>{const r=B(t,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...e});return this.underlyingSocket="socket"in r?r.socket:r,r}),t,e,r),this.underlyingSocket=void 0}call(...t){const e=this.underlyingSocket?.readyState;return 1===e?super.call(...t):Promise.reject(new Error("Tried to call a JSON-RPC method `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}notify(...t){const e=this.underlyingSocket?.readyState;return 1===e?super.notify(...t):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}}class sr{constructor(t){this.key=void 0,this.state=void 0,this.key=t.key,this.state=t.state}isActive(){const t=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===t}static deserialize(t){const e=function(t,e){let r;try{r=t.layout.decode(e)}catch(t){throw new Error("invalid instruction; "+t)}if(r.typeIndex!==t.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${t.index}`);return r}(ir,t),r=t.length-56;ae(r>=0,"lookup table is invalid"),ae(r%32==0,"lookup table is invalid");const n=r/32,{addresses:s}=a.struct([a.seq(ee(),n,"addresses")]).decode(t.slice(56));return{deactivationSlot:e.deactivationSlot,lastExtendedSlot:e.lastExtendedSlot,lastExtendedSlotStartIndex:e.lastExtendedStartIndex,authority:0!==e.authority.length?new Ft(e.authority[0]):void 0,addresses:s.map((t=>new Ft(t)))}}}const ir={index:1,layout:a.struct([a.u32("typeIndex"),Me("deactivationSlot"),a.nu64("lastExtendedSlot"),a.u8("lastExtendedStartIndex"),a.u8(),a.seq(ee(),a.offset(a.u8(),-1),"authority")])},or=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;const ar=h(d(Ft),g(),(t=>new Ft(t))),cr=p([g(),y("base64")]),ur=h(d(j),cr,(t=>j.from(t[0],"base64"))),lr=3e4;function hr(t){let e,r;if("string"==typeof t)e=t;else if(t){const{commitment:n,...s}=t;e=n,r=s}return{commitment:e,config:r}}function dr(t){return t.map((t=>"memcmp"in t?{...t,memcmp:{...t.memcmp,encoding:t.memcmp.encoding??"base58"}}:t))}function gr(t){return v([m({jsonrpc:y("2.0"),id:g(),result:t}),m({jsonrpc:y("2.0"),id:g(),error:m({code:f(),message:g(),data:S(P())})})])}const pr=gr(f());function yr(t){return h(gr(t),pr,(e=>"error"in e?e:{...e,result:_(e.result,t)}))}function fr(t){return yr(m({context:m({slot:b()}),value:t}))}function mr(t){return m({context:m({slot:b()}),value:t})}function br(t,e){return 0===t?new ge({header:e.header,staticAccountKeys:e.accountKeys.map((t=>new Ft(t))),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map((t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:r.decode(t.data)}))),addressTableLookups:e.addressTableLookups}):new de(e)}const kr=m({foundation:b(),foundationTerm:b(),initial:b(),taper:b(),terminal:b()}),wr=yr(k(w(m({epoch:b(),effectiveSlot:b(),amount:b(),postBalance:b(),commission:S(w(b()))})))),Sr=k(m({slot:b(),prioritizationFee:b()})),Ir=m({total:b(),validator:b(),foundation:b(),epoch:b()}),Ar=m({epoch:b(),slotIndex:b(),slotsInEpoch:b(),absoluteSlot:b(),blockHeight:S(b()),transactionCount:S(b())}),vr=m({slotsPerEpoch:b(),leaderScheduleSlotOffset:b(),warmup:I(),firstNormalEpoch:b(),firstNormalSlot:b()}),_r=A(g(),k(b())),Pr=w(v([m({}),g()])),Er=m({err:Pr}),Rr=y("receivedSignature"),Tr=m({"solana-core":g(),"feature-set":S(b())}),Br=m({program:g(),programId:ar,parsed:f()}),xr=m({programId:ar,accounts:k(ar),data:g()}),Cr=fr(m({err:w(v([m({}),g()])),logs:w(k(g())),accounts:S(w(k(w(m({executable:I(),owner:g(),lamports:b(),data:k(g()),rentEpoch:S(b())}))))),unitsConsumed:S(b()),returnData:S(w(m({programId:g(),data:p([g(),y("base64")])}))),innerInstructions:S(w(k(m({index:b(),instructions:k(v([Br,xr]))}))))})),Lr=fr(m({byIdentity:A(g(),k(b())),range:m({firstSlot:b(),lastSlot:b()})}));const zr=yr(kr),Wr=yr(Ir),Or=yr(Sr),Kr=yr(Ar),Nr=yr(vr),Ur=yr(_r),qr=yr(b()),Mr=fr(m({total:b(),circulating:b(),nonCirculating:b(),nonCirculatingAccounts:k(ar)})),Dr=m({amount:g(),uiAmount:w(b()),decimals:b(),uiAmountString:S(g())}),Vr=fr(k(m({address:ar,amount:g(),uiAmount:w(b()),decimals:b(),uiAmountString:S(g())}))),$r=fr(k(m({pubkey:ar,account:m({executable:I(),owner:ar,lamports:b(),data:ur,rentEpoch:b()})}))),Fr=m({program:g(),parsed:f(),space:b()}),Hr=fr(k(m({pubkey:ar,account:m({executable:I(),owner:ar,lamports:b(),data:Fr,rentEpoch:b()})}))),jr=fr(k(m({lamports:b(),address:ar}))),Yr=m({executable:I(),owner:ar,lamports:b(),data:ur,rentEpoch:b()}),Jr=m({pubkey:ar,account:Yr}),Gr=h(v([d(j),Fr]),v([cr,Fr]),(t=>Array.isArray(t)?_(t,ur):t)),Xr=m({executable:I(),owner:ar,lamports:b(),data:Gr,rentEpoch:b()}),Zr=m({pubkey:ar,account:Xr}),Qr=m({state:v([y("active"),y("inactive"),y("activating"),y("deactivating")]),active:b(),inactive:b()}),tn=yr(k(m({signature:g(),slot:b(),err:Pr,memo:w(g()),blockTime:S(w(b()))}))),en=yr(k(m({signature:g(),slot:b(),err:Pr,memo:w(g()),blockTime:S(w(b()))}))),rn=m({subscription:b(),result:mr(Yr)}),nn=m({pubkey:ar,account:Yr}),sn=m({subscription:b(),result:mr(nn)}),on=m({parent:b(),slot:b(),root:b()}),an=m({subscription:b(),result:on}),cn=v([m({type:v([y("firstShredReceived"),y("completed"),y("optimisticConfirmation"),y("root")]),slot:b(),timestamp:b()}),m({type:y("createdBank"),parent:b(),slot:b(),timestamp:b()}),m({type:y("frozen"),slot:b(),timestamp:b(),stats:m({numTransactionEntries:b(),numSuccessfulTransactions:b(),numFailedTransactions:b(),maxTransactionsPerEntry:b()})}),m({type:y("dead"),slot:b(),timestamp:b(),err:g()})]),un=m({subscription:b(),result:cn}),ln=m({subscription:b(),result:mr(v([Er,Rr]))}),hn=m({subscription:b(),result:b()}),dn=m({pubkey:g(),gossip:w(g()),tpu:w(g()),rpc:w(g()),version:w(g())}),gn=m({votePubkey:g(),nodePubkey:g(),activatedStake:b(),epochVoteAccount:I(),epochCredits:k(p([b(),b(),b()])),commission:b(),lastVote:b(),rootSlot:w(b())}),pn=yr(m({current:k(gn),delinquent:k(gn)})),yn=v([y("processed"),y("confirmed"),y("finalized")]),fn=m({slot:b(),confirmations:w(b()),err:Pr,confirmationStatus:S(yn)}),mn=fr(k(w(fn))),bn=yr(b()),kn=m({accountKey:ar,writableIndexes:k(b()),readonlyIndexes:k(b())}),wn=m({signatures:k(g()),message:m({accountKeys:k(g()),header:m({numRequiredSignatures:b(),numReadonlySignedAccounts:b(),numReadonlyUnsignedAccounts:b()}),instructions:k(m({accounts:k(b()),data:g(),programIdIndex:b()})),recentBlockhash:g(),addressTableLookups:S(k(kn))})}),Sn=m({pubkey:ar,signer:I(),writable:I(),source:S(v([y("transaction"),y("lookupTable")]))}),In=m({accountKeys:k(Sn),signatures:k(g())}),An=m({parsed:f(),program:g(),programId:ar}),vn=m({accounts:k(ar),data:g(),programId:ar}),_n=v([vn,An]),Pn=v([m({parsed:f(),program:g(),programId:g()}),m({accounts:k(g()),data:g(),programId:g()})]),En=h(_n,Pn,(t=>_(t,"accounts"in t?vn:An))),Rn=m({signatures:k(g()),message:m({accountKeys:k(Sn),instructions:k(En),recentBlockhash:g(),addressTableLookups:S(w(k(kn)))})}),Tn=m({accountIndex:b(),mint:g(),owner:S(g()),uiTokenAmount:Dr}),Bn=m({writable:k(ar),readonly:k(ar)}),xn=m({err:Pr,fee:b(),innerInstructions:S(w(k(m({index:b(),instructions:k(m({accounts:k(b()),data:g(),programIdIndex:b()}))})))),preBalances:k(b()),postBalances:k(b()),logMessages:S(w(k(g()))),preTokenBalances:S(w(k(Tn))),postTokenBalances:S(w(k(Tn))),loadedAddresses:S(Bn),computeUnitsConsumed:S(b())}),Cn=m({err:Pr,fee:b(),innerInstructions:S(w(k(m({index:b(),instructions:k(En)})))),preBalances:k(b()),postBalances:k(b()),logMessages:S(w(k(g()))),preTokenBalances:S(w(k(Tn))),postTokenBalances:S(w(k(Tn))),loadedAddresses:S(Bn),computeUnitsConsumed:S(b())}),Ln=v([y(0),y("legacy")]),zn=m({pubkey:g(),lamports:b(),postBalance:w(b()),rewardType:w(g()),commission:S(w(b()))}),Wn=yr(w(m({blockhash:g(),previousBlockhash:g(),parentSlot:b(),transactions:k(m({transaction:wn,meta:w(xn),version:S(Ln)})),rewards:S(k(zn)),blockTime:w(b()),blockHeight:w(b())}))),On=yr(w(m({blockhash:g(),previousBlockhash:g(),parentSlot:b(),rewards:S(k(zn)),blockTime:w(b()),blockHeight:w(b())}))),Kn=yr(w(m({blockhash:g(),previousBlockhash:g(),parentSlot:b(),transactions:k(m({transaction:In,meta:w(xn),version:S(Ln)})),rewards:S(k(zn)),blockTime:w(b()),blockHeight:w(b())}))),Nn=yr(w(m({blockhash:g(),previousBlockhash:g(),parentSlot:b(),transactions:k(m({transaction:Rn,meta:w(Cn),version:S(Ln)})),rewards:S(k(zn)),blockTime:w(b()),blockHeight:w(b())}))),Un=yr(w(m({blockhash:g(),previousBlockhash:g(),parentSlot:b(),transactions:k(m({transaction:In,meta:w(Cn),version:S(Ln)})),rewards:S(k(zn)),blockTime:w(b()),blockHeight:w(b())}))),qn=yr(w(m({blockhash:g(),previousBlockhash:g(),parentSlot:b(),rewards:S(k(zn)),blockTime:w(b()),blockHeight:w(b())}))),Mn=yr(w(m({blockhash:g(),previousBlockhash:g(),parentSlot:b(),transactions:k(m({transaction:wn,meta:w(xn)})),rewards:S(k(zn)),blockTime:w(b())}))),Dn=yr(w(m({blockhash:g(),previousBlockhash:g(),parentSlot:b(),signatures:k(g()),blockTime:w(b())}))),Vn=yr(w(m({slot:b(),meta:w(xn),blockTime:S(w(b())),transaction:wn,version:S(Ln)}))),$n=yr(w(m({slot:b(),transaction:Rn,meta:w(Cn),blockTime:S(w(b())),version:S(Ln)}))),Fn=fr(m({blockhash:g(),feeCalculator:m({lamportsPerSignature:b()})})),Hn=fr(m({blockhash:g(),lastValidBlockHeight:b()})),jn=fr(I()),Yn=m({slot:b(),numTransactions:b(),numSlots:b(),samplePeriodSecs:b()}),Jn=yr(k(Yn)),Gn=fr(w(m({feeCalculator:m({lamportsPerSignature:b()})}))),Xn=yr(g()),Zn=yr(g()),Qn=m({err:Pr,logs:k(g()),signature:g()}),ts=m({result:mr(Qn),subscription:b()}),es={"solana-client":"js/1.0.0-maintenance"};class rs{constructor(t,e){let r,n,s,i,o,a;var c;this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const t={};return async e=>{const{commitment:r,config:n}=hr(e),s=this._buildArgs([],r,void 0,n),i=Qe(s);return t[i]=t[i]??(async()=>{try{const t=await this._rpcRequest("getBlockHeight",s),e=_(t,yr(b()));if("error"in e)throw new Ce(e.error,"failed to get block height information");return e.result}finally{delete t[i]}})(),await t[i]}})(),e&&"string"==typeof e?this._commitment=e:e&&(this._commitment=e.commitment,this._confirmTransactionInitialTimeout=e.confirmTransactionInitialTimeout,r=e.wsEndpoint,n=e.httpHeaders,s=e.fetch,i=e.fetchMiddleware,o=e.disableRetryOnRateLimit,a=e.httpAgent),this._rpcEndpoint=function(t){if(!1===/^https?:/.test(t))throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return t}(t),this._rpcWsEndpoint=r||function(t){const e=t.match(or);if(null==e)throw TypeError(`Failed to validate endpoint URL \`${t}\``);const[r,n,s,i]=e,o=t.startsWith("https:")?"wss:":"ws:",a=null==s?null:parseInt(s.slice(1),10);return`${o}//${n}${null==a?"":`:${a+1}`}${i}`}(t),this._rpcClient=function(t,e,r,n,s,i){const o=r||rr;let a;return null!=i&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."),n&&(a=async(t,e)=>{const r=await new Promise(((r,s)=>{try{n(t,e,((t,e)=>r([t,e])))}catch(t){s(t)}}));return await o(...r)}),new R((async(r,n)=>{const i={method:"POST",body:r,agent:void 0,headers:Object.assign({"Content-Type":"application/json"},e||{},es)};try{let e,r=5,c=500;for(;e=a?await a(t,i):await o(t,i),429===e.status&&!0!==s&&(r-=1,0!==r);)console.error(`Server responded with ${e.status} ${e.statusText}.  Retrying after ${c}ms delay...`),await ze(c),c*=2;const u=await e.text();e.ok?n(null,u):n(new Error(`${e.status} ${e.statusText}: ${u}`))}catch(t){t instanceof Error&&n(t)}}),{})}(t,n,s,i,o,a),this._rpcRequest=(c=this._rpcClient,(t,e)=>new Promise(((r,n)=>{c.request(t,e,((t,e)=>{t?n(t):r(e)}))}))),this._rpcBatchRequest=function(t){return e=>new Promise(((r,n)=>{0===e.length&&r([]);const s=e.map((e=>t.request(e.methodName,e.args)));t.request(s,((t,e)=>{t?n(t):r(e)}))}))}(this._rpcClient),this._rpcWebSocket=new nr(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(t,e){const{commitment:r,config:n}=hr(e),s=this._buildArgs([t.toBase58()],r,void 0,n),i=await this._rpcRequest("getBalance",s),o=_(i,fr(b()));if("error"in o)throw new Ce(o.error,`failed to get balance for ${t.toBase58()}`);return o.result}async getBalance(t,e){return await this.getBalanceAndContext(t,e).then((t=>t.value)).catch((e=>{throw new Error("failed to get balance of account "+t.toBase58()+": "+e)}))}async getBlockTime(t){const e=await this._rpcRequest("getBlockTime",[t]),r=_(e,yr(w(b())));if("error"in r)throw new Ce(r.error,`failed to get block time for slot ${t}`);return r.result}async getMinimumLedgerSlot(){const t=await this._rpcRequest("minimumLedgerSlot",[]),e=_(t,yr(b()));if("error"in e)throw new Ce(e.error,"failed to get minimum ledger slot");return e.result}async getFirstAvailableBlock(){const t=await this._rpcRequest("getFirstAvailableBlock",[]),e=_(t,qr);if("error"in e)throw new Ce(e.error,"failed to get first available block");return e.result}async getSupply(t){let e={};e="string"==typeof t?{commitment:t}:t?{...t,commitment:t&&t.commitment||this.commitment}:{commitment:this.commitment};const r=await this._rpcRequest("getSupply",[e]),n=_(r,Mr);if("error"in n)throw new Ce(n.error,"failed to get supply");return n.result}async getTokenSupply(t,e){const r=this._buildArgs([t.toBase58()],e),n=await this._rpcRequest("getTokenSupply",r),s=_(n,fr(Dr));if("error"in s)throw new Ce(s.error,"failed to get token supply");return s.result}async getTokenAccountBalance(t,e){const r=this._buildArgs([t.toBase58()],e),n=await this._rpcRequest("getTokenAccountBalance",r),s=_(n,fr(Dr));if("error"in s)throw new Ce(s.error,"failed to get token account balance");return s.result}async getTokenAccountsByOwner(t,e,r){const{commitment:n,config:s}=hr(r);let i=[t.toBase58()];"mint"in e?i.push({mint:e.mint.toBase58()}):i.push({programId:e.programId.toBase58()});const o=this._buildArgs(i,n,"base64",s),a=await this._rpcRequest("getTokenAccountsByOwner",o),c=_(a,$r);if("error"in c)throw new Ce(c.error,`failed to get token accounts owned by account ${t.toBase58()}`);return c.result}async getParsedTokenAccountsByOwner(t,e,r){let n=[t.toBase58()];"mint"in e?n.push({mint:e.mint.toBase58()}):n.push({programId:e.programId.toBase58()});const s=this._buildArgs(n,r,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",s),o=_(i,Hr);if("error"in o)throw new Ce(o.error,`failed to get token accounts owned by account ${t.toBase58()}`);return o.result}async getLargestAccounts(t){const e={...t,commitment:t&&t.commitment||this.commitment},r=e.filter||e.commitment?[e]:[],n=await this._rpcRequest("getLargestAccounts",r),s=_(n,jr);if("error"in s)throw new Ce(s.error,"failed to get largest accounts");return s.result}async getTokenLargestAccounts(t,e){const r=this._buildArgs([t.toBase58()],e),n=await this._rpcRequest("getTokenLargestAccounts",r),s=_(n,Vr);if("error"in s)throw new Ce(s.error,"failed to get token largest accounts");return s.result}async getAccountInfoAndContext(t,e){const{commitment:r,config:n}=hr(e),s=this._buildArgs([t.toBase58()],r,"base64",n),i=await this._rpcRequest("getAccountInfo",s),o=_(i,fr(w(Yr)));if("error"in o)throw new Ce(o.error,`failed to get info about account ${t.toBase58()}`);return o.result}async getParsedAccountInfo(t,e){const{commitment:r,config:n}=hr(e),s=this._buildArgs([t.toBase58()],r,"jsonParsed",n),i=await this._rpcRequest("getAccountInfo",s),o=_(i,fr(w(Xr)));if("error"in o)throw new Ce(o.error,`failed to get info about account ${t.toBase58()}`);return o.result}async getAccountInfo(t,e){try{return(await this.getAccountInfoAndContext(t,e)).value}catch(e){throw new Error("failed to get info about account "+t.toBase58()+": "+e)}}async getMultipleParsedAccounts(t,e){const{commitment:r,config:n}=hr(e),s=t.map((t=>t.toBase58())),i=this._buildArgs([s],r,"jsonParsed",n),o=await this._rpcRequest("getMultipleAccounts",i),a=_(o,fr(k(w(Xr))));if("error"in a)throw new Ce(a.error,`failed to get info for accounts ${s}`);return a.result}async getMultipleAccountsInfoAndContext(t,e){const{commitment:r,config:n}=hr(e),s=t.map((t=>t.toBase58())),i=this._buildArgs([s],r,"base64",n),o=await this._rpcRequest("getMultipleAccounts",i),a=_(o,fr(k(w(Yr))));if("error"in a)throw new Ce(a.error,`failed to get info for accounts ${s}`);return a.result}async getMultipleAccountsInfo(t,e){return(await this.getMultipleAccountsInfoAndContext(t,e)).value}async getStakeActivation(t,e,r){const{commitment:n,config:s}=hr(e),i=this._buildArgs([t.toBase58()],n,void 0,{...s,epoch:null!=r?r:s?.epoch}),o=await this._rpcRequest("getStakeActivation",i),a=_(o,yr(Qr));if("error"in a)throw new Ce(a.error,`failed to get Stake Activation ${t.toBase58()}`);return a.result}async getProgramAccounts(t,e){const{commitment:r,config:n}=hr(e),{encoding:s,...i}=n||{},o=this._buildArgs([t.toBase58()],r,s||"base64",{...i,...i.filters?{filters:dr(i.filters)}:null}),a=await this._rpcRequest("getProgramAccounts",o),c=k(Jr),u=!0===i.withContext?_(a,fr(c)):_(a,yr(c));if("error"in u)throw new Ce(u.error,`failed to get accounts owned by program ${t.toBase58()}`);return u.result}async getParsedProgramAccounts(t,e){const{commitment:r,config:n}=hr(e),s=this._buildArgs([t.toBase58()],r,"jsonParsed",n),i=await this._rpcRequest("getProgramAccounts",s),o=_(i,yr(k(Zr)));if("error"in o)throw new Ce(o.error,`failed to get accounts owned by program ${t.toBase58()}`);return o.result}async confirmTransaction(t,e){let n,s;if("string"==typeof t)n=t;else{const e=t;if(e.abortSignal?.aborted)return Promise.reject(e.abortSignal.reason);n=e.signature}try{s=r.decode(n)}catch(t){throw new Error("signature must be base58 encoded: "+n)}return ae(64===s.length,"signature has invalid length"),"string"==typeof t?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:e||this.commitment,signature:n}):"lastValidBlockHeight"in t?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e||this.commitment,strategy:t}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:e||this.commitment,strategy:t})}getCancellationPromise(t){return new Promise(((e,r)=>{null!=t&&(t.aborted?r(t.reason):t.addEventListener("abort",(()=>{r(t.reason)})))}))}getTransactionConfirmationPromise({commitment:t,signature:e}){let r,n,s=!1;return{abortConfirmation:()=>{n&&(n(),n=void 0),null!=r&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:new Promise(((i,o)=>{try{r=this.onSignature(e,((t,e)=>{r=void 0;const n={context:e,value:t};i({__type:ye.PROCESSED,response:n})}),t);const a=new Promise((t=>{null==r?t():n=this._onSubscriptionStateChange(r,(e=>{"subscribed"===e&&t()}))}));(async()=>{if(await a,s)return;const r=await this.getSignatureStatus(e);if(s)return;if(null==r)return;const{context:n,value:c}=r;if(null!=c)if(c?.err)o(c.err);else{switch(t){case"confirmed":case"single":case"singleGossip":if("processed"===c.confirmationStatus)return;break;case"finalized":case"max":case"root":if("processed"===c.confirmationStatus||"confirmed"===c.confirmationStatus)return}s=!0,i({__type:ye.PROCESSED,response:{context:n,value:c}})}})()}catch(t){o(t)}}))}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t,strategy:{abortSignal:e,lastValidBlockHeight:r,signature:n}}){let s=!1;const i=new Promise((e=>{const n=async()=>{try{return await this.getBlockHeight(t)}catch(t){return-1}};(async()=>{let t=await n();if(!s){for(;t<=r;){if(await ze(1e3),s)return;if(t=await n(),s)return}e({__type:ye.BLOCKHEIGHT_EXCEEDED})}})()})),{abortConfirmation:o,confirmationPromise:a}=this.getTransactionConfirmationPromise({commitment:t,signature:n}),c=this.getCancellationPromise(e);let u;try{const t=await Promise.race([c,a,i]);if(t.__type!==ye.PROCESSED)throw new Xt(n);u=t.response}finally{s=!0,o()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:t,strategy:{abortSignal:e,minContextSlot:r,nonceAccountPubkey:n,nonceValue:s,signature:i}}){let o=!1;const a=new Promise((e=>{let i=s,a=null;const c=async()=>{try{const{context:e,value:s}=await this.getNonceAndContext(n,{commitment:t,minContextSlot:r});return a=e.slot,s?.nonce}catch(t){return i}};(async()=>{if(i=await c(),!o)for(;;){if(s!==i)return void e({__type:ye.NONCE_INVALID,slotInWhichNonceDidAdvance:a});if(await ze(2e3),o)return;if(i=await c(),o)return}})()})),{abortConfirmation:c,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:t,signature:i}),l=this.getCancellationPromise(e);let h;try{const e=await Promise.race([l,u,a]);if(e.__type===ye.PROCESSED)h=e.response;else{let n;for(;;){const t=await this.getSignatureStatus(i);if(null==t)break;if(!(t.context.slot<(e.slotInWhichNonceDidAdvance??r))){n=t;break}await ze(400)}if(!n?.value)throw new Qt(i);{const e=t||"finalized",{confirmationStatus:r}=n.value;switch(e){case"processed":case"recent":if("processed"!==r&&"confirmed"!==r&&"finalized"!==r)throw new Qt(i);break;case"confirmed":case"single":case"singleGossip":if("confirmed"!==r&&"finalized"!==r)throw new Qt(i);break;case"finalized":case"max":case"root":if("finalized"!==r)throw new Qt(i)}h={context:n.context,value:{err:n.value.err}}}}}finally{o=!0,c()}return h}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:t,signature:e}){let r;const n=new Promise((e=>{let n=this._confirmTransactionInitialTimeout||6e4;switch(t){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":n=this._confirmTransactionInitialTimeout||3e4}r=setTimeout((()=>e({__type:ye.TIMED_OUT,timeoutMs:n})),n)})),{abortConfirmation:s,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:t,signature:e});let o;try{const t=await Promise.race([i,n]);if(t.__type!==ye.PROCESSED)throw new Zt(e,t.timeoutMs/1e3);o=t.response}finally{clearTimeout(r),s()}return o}async getClusterNodes(){const t=await this._rpcRequest("getClusterNodes",[]),e=_(t,yr(k(dn)));if("error"in e)throw new Ce(e.error,"failed to get cluster nodes");return e.result}async getVoteAccounts(t){const e=this._buildArgs([],t),r=await this._rpcRequest("getVoteAccounts",e),n=_(r,pn);if("error"in n)throw new Ce(n.error,"failed to get vote accounts");return n.result}async getSlot(t){const{commitment:e,config:r}=hr(t),n=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getSlot",n),i=_(s,yr(b()));if("error"in i)throw new Ce(i.error,"failed to get slot");return i.result}async getSlotLeader(t){const{commitment:e,config:r}=hr(t),n=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getSlotLeader",n),i=_(s,yr(g()));if("error"in i)throw new Ce(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(t,e){const r=[t,e],n=await this._rpcRequest("getSlotLeaders",r),s=_(n,yr(k(ar)));if("error"in s)throw new Ce(s.error,"failed to get slot leaders");return s.result}async getSignatureStatus(t,e){const{context:r,value:n}=await this.getSignatureStatuses([t],e);ae(1===n.length);return{context:r,value:n[0]}}async getSignatureStatuses(t,e){const r=[t];e&&r.push(e);const n=await this._rpcRequest("getSignatureStatuses",r),s=_(n,mn);if("error"in s)throw new Ce(s.error,"failed to get signature status");return s.result}async getTransactionCount(t){const{commitment:e,config:r}=hr(t),n=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getTransactionCount",n),i=_(s,yr(b()));if("error"in i)throw new Ce(i.error,"failed to get transaction count");return i.result}async getTotalSupply(t){return(await this.getSupply({commitment:t,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(t){const e=this._buildArgs([],t),r=await this._rpcRequest("getInflationGovernor",e),n=_(r,zr);if("error"in n)throw new Ce(n.error,"failed to get inflation");return n.result}async getInflationReward(t,e,r){const{commitment:n,config:s}=hr(r),i=this._buildArgs([t.map((t=>t.toBase58()))],n,void 0,{...s,epoch:null!=e?e:s?.epoch}),o=await this._rpcRequest("getInflationReward",i),a=_(o,wr);if("error"in a)throw new Ce(a.error,"failed to get inflation reward");return a.result}async getInflationRate(){const t=await this._rpcRequest("getInflationRate",[]),e=_(t,Wr);if("error"in e)throw new Ce(e.error,"failed to get inflation rate");return e.result}async getEpochInfo(t){const{commitment:e,config:r}=hr(t),n=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getEpochInfo",n),i=_(s,Kr);if("error"in i)throw new Ce(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const t=await this._rpcRequest("getEpochSchedule",[]),e=_(t,Nr);if("error"in e)throw new Ce(e.error,"failed to get epoch schedule");const r=e.result;return new er(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const t=await this._rpcRequest("getLeaderSchedule",[]),e=_(t,Ur);if("error"in e)throw new Ce(e.error,"failed to get leader schedule");return e.result}async getMinimumBalanceForRentExemption(t,e){const r=this._buildArgs([t],e),n=await this._rpcRequest("getMinimumBalanceForRentExemption",r),s=_(n,bn);return"error"in s?(console.warn("Unable to fetch minimum balance for rent exemption"),0):s.result}async getRecentBlockhashAndContext(t){const e=this._buildArgs([],t),r=await this._rpcRequest("getRecentBlockhash",e),n=_(r,Fn);if("error"in n)throw new Ce(n.error,"failed to get recent blockhash");return n.result}async getRecentPerformanceSamples(t){const e=await this._rpcRequest("getRecentPerformanceSamples",t?[t]:[]),r=_(e,Jn);if("error"in r)throw new Ce(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(t,e){const r=this._buildArgs([t],e),n=await this._rpcRequest("getFeeCalculatorForBlockhash",r),s=_(n,Gn);if("error"in s)throw new Ce(s.error,"failed to get fee calculator");const{context:i,value:o}=s.result;return{context:i,value:null!==o?o.feeCalculator:null}}async getFeeForMessage(t,e){const r=Kt(t.serialize()).toString("base64"),n=this._buildArgs([r],e),s=await this._rpcRequest("getFeeForMessage",n),i=_(s,fr(w(b())));if("error"in i)throw new Ce(i.error,"failed to get fee for message");if(null===i.result)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(t){const e=t?.lockedWritableAccounts?.map((t=>t.toBase58())),r=e?.length?[e]:[],n=await this._rpcRequest("getRecentPrioritizationFees",r),s=_(n,Or);if("error"in s)throw new Ce(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(t){try{return(await this.getRecentBlockhashAndContext(t)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(t){try{return(await this.getLatestBlockhashAndContext(t)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(t){const{commitment:e,config:r}=hr(t),n=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getLatestBlockhash",n),i=_(s,Hn);if("error"in i)throw new Ce(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(t,e){const{commitment:r,config:n}=hr(e),s=this._buildArgs([t],r,void 0,n),i=await this._rpcRequest("isBlockhashValid",s),o=_(i,jn);if("error"in o)throw new Ce(o.error,"failed to determine if the blockhash `"+t+"`is valid");return o.result}async getVersion(){const t=await this._rpcRequest("getVersion",[]),e=_(t,yr(Tr));if("error"in e)throw new Ce(e.error,"failed to get version");return e.result}async getGenesisHash(){const t=await this._rpcRequest("getGenesisHash",[]),e=_(t,yr(g()));if("error"in e)throw new Ce(e.error,"failed to get genesis hash");return e.result}async getBlock(t,e){const{commitment:r,config:n}=hr(e),s=this._buildArgsAtLeastConfirmed([t],r,void 0,n),i=await this._rpcRequest("getBlock",s);try{switch(n?.transactionDetails){case"accounts":{const t=_(i,Kn);if("error"in t)throw t.error;return t.result}case"none":{const t=_(i,On);if("error"in t)throw t.error;return t.result}default:{const t=_(i,Wn);if("error"in t)throw t.error;const{result:e}=t;return e?{...e,transactions:e.transactions.map((({transaction:t,meta:e,version:r})=>({meta:e,transaction:{...t,message:br(r,t.message)},version:r})))}:null}}}catch(t){throw new Ce(t,"failed to get confirmed block")}}async getParsedBlock(t,e){const{commitment:r,config:n}=hr(e),s=this._buildArgsAtLeastConfirmed([t],r,"jsonParsed",n),i=await this._rpcRequest("getBlock",s);try{switch(n?.transactionDetails){case"accounts":{const t=_(i,Un);if("error"in t)throw t.error;return t.result}case"none":{const t=_(i,qn);if("error"in t)throw t.error;return t.result}default:{const t=_(i,Nn);if("error"in t)throw t.error;return t.result}}}catch(t){throw new Ce(t,"failed to get block")}}async getBlockProduction(t){let e,r;if("string"==typeof t)r=t;else if(t){const{commitment:n,...s}=t;r=n,e=s}const n=this._buildArgs([],r,"base64",e),s=await this._rpcRequest("getBlockProduction",n),i=_(s,Lr);if("error"in i)throw new Ce(i.error,"failed to get block production information");return i.result}async getTransaction(t,e){const{commitment:r,config:n}=hr(e),s=this._buildArgsAtLeastConfirmed([t],r,void 0,n),i=await this._rpcRequest("getTransaction",s),o=_(i,Vn);if("error"in o)throw new Ce(o.error,"failed to get transaction");const a=o.result;return a?{...a,transaction:{...a.transaction,message:br(a.version,a.transaction.message)}}:a}async getParsedTransaction(t,e){const{commitment:r,config:n}=hr(e),s=this._buildArgsAtLeastConfirmed([t],r,"jsonParsed",n),i=await this._rpcRequest("getTransaction",s),o=_(i,$n);if("error"in o)throw new Ce(o.error,"failed to get transaction");return o.result}async getParsedTransactions(t,e){const{commitment:r,config:n}=hr(e),s=t.map((t=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([t],r,"jsonParsed",n)})));return(await this._rpcBatchRequest(s)).map((t=>{const e=_(t,$n);if("error"in e)throw new Ce(e.error,"failed to get transactions");return e.result}))}async getTransactions(t,e){const{commitment:r,config:n}=hr(e),s=t.map((t=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([t],r,void 0,n)})));return(await this._rpcBatchRequest(s)).map((t=>{const e=_(t,Vn);if("error"in e)throw new Ce(e.error,"failed to get transactions");const r=e.result;return r?{...r,transaction:{...r.transaction,message:br(r.version,r.transaction.message)}}:r}))}async getConfirmedBlock(t,e){const r=this._buildArgsAtLeastConfirmed([t],e),n=await this._rpcRequest("getConfirmedBlock",r),s=_(n,Mn);if("error"in s)throw new Ce(s.error,"failed to get confirmed block");const i=s.result;if(!i)throw new Error("Confirmed block "+t+" not found");const o={...i,transactions:i.transactions.map((({transaction:t,meta:e})=>{const r=new de(t.message);return{meta:e,transaction:{...t,message:r}}}))};return{...o,transactions:o.transactions.map((({transaction:t,meta:e})=>({meta:e,transaction:be.populate(t.message,t.signatures)})))}}async getBlocks(t,e,r){const n=this._buildArgsAtLeastConfirmed(void 0!==e?[t,e]:[t],r),s=await this._rpcRequest("getBlocks",n),i=_(s,yr(k(b())));if("error"in i)throw new Ce(i.error,"failed to get blocks");return i.result}async getBlockSignatures(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getBlock",r),s=_(n,Dn);if("error"in s)throw new Ce(s.error,"failed to get block");const i=s.result;if(!i)throw new Error("Block "+t+" not found");return i}async getConfirmedBlockSignatures(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),n=await this._rpcRequest("getConfirmedBlock",r),s=_(n,Dn);if("error"in s)throw new Ce(s.error,"failed to get confirmed block");const i=s.result;if(!i)throw new Error("Confirmed block "+t+" not found");return i}async getConfirmedTransaction(t,e){const r=this._buildArgsAtLeastConfirmed([t],e),n=await this._rpcRequest("getConfirmedTransaction",r),s=_(n,Vn);if("error"in s)throw new Ce(s.error,"failed to get transaction");const i=s.result;if(!i)return i;const o=new de(i.transaction.message),a=i.transaction.signatures;return{...i,transaction:be.populate(o,a)}}async getParsedConfirmedTransaction(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,"jsonParsed"),n=await this._rpcRequest("getConfirmedTransaction",r),s=_(n,$n);if("error"in s)throw new Ce(s.error,"failed to get confirmed transaction");return s.result}async getParsedConfirmedTransactions(t,e){const r=t.map((t=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([t],e,"jsonParsed")})));return(await this._rpcBatchRequest(r)).map((t=>{const e=_(t,$n);if("error"in e)throw new Ce(e.error,"failed to get confirmed transactions");return e.result}))}async getConfirmedSignaturesForAddress(t,e,r){let n={},s=await this.getFirstAvailableBlock();for(;!("until"in n)&&!(--e<=0||e<s);)try{const t=await this.getConfirmedBlockSignatures(e,"finalized");t.signatures.length>0&&(n.until=t.signatures[t.signatures.length-1].toString())}catch(t){if(t instanceof Error&&t.message.includes("skipped"))continue;throw t}let i=await this.getSlot("finalized");for(;!("before"in n||++r>i);)try{const t=await this.getConfirmedBlockSignatures(r);t.signatures.length>0&&(n.before=t.signatures[t.signatures.length-1].toString())}catch(t){if(t instanceof Error&&t.message.includes("skipped"))continue;throw t}return(await this.getConfirmedSignaturesForAddress2(t,n)).map((t=>t.signature))}async getConfirmedSignaturesForAddress2(t,e,r){const n=this._buildArgsAtLeastConfirmed([t.toBase58()],r,void 0,e),s=await this._rpcRequest("getConfirmedSignaturesForAddress2",n),i=_(s,tn);if("error"in i)throw new Ce(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(t,e,r){const n=this._buildArgsAtLeastConfirmed([t.toBase58()],r,void 0,e),s=await this._rpcRequest("getSignaturesForAddress",n),i=_(s,en);if("error"in i)throw new Ce(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(t,e){const{context:r,value:n}=await this.getAccountInfoAndContext(t,e);let s=null;return null!==n&&(s=new sr({key:t,state:sr.deserialize(n.data)})),{context:r,value:s}}async getNonceAndContext(t,e){const{context:r,value:n}=await this.getAccountInfoAndContext(t,e);let s=null;return null!==n&&(s=qe.fromAccountData(n.data)),{context:r,value:s}}async getNonce(t,e){return await this.getNonceAndContext(t,e).then((t=>t.value)).catch((e=>{throw new Error("failed to get nonce for account "+t.toBase58()+": "+e)}))}async requestAirdrop(t,e){const r=await this._rpcRequest("requestAirdrop",[t.toBase58(),e]),n=_(r,Xn);if("error"in n)throw new Ce(n.error,`airdrop to ${t.toBase58()} failed`);return n.result}async _blockhashWithExpiryBlockHeight(t){if(!t){for(;this._pollingBlockhash;)await ze(100);const t=Date.now()-this._blockhashInfo.lastFetch>=3e4;if(null!==this._blockhashInfo.latestBlockhash&&!t)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const t=Date.now(),e=this._blockhashInfo.latestBlockhash,r=e?e.blockhash:null;for(let t=0;t<50;t++){const t=await this.getLatestBlockhash("finalized");if(r!==t.blockhash)return this._blockhashInfo={latestBlockhash:t,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},t;await ze(200)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-t}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(t){const{commitment:e,config:r}=hr(t),n=this._buildArgs([],e,"base64",r),s=await this._rpcRequest("getStakeMinimumDelegation",n),i=_(s,fr(b()));if("error"in i)throw new Ce(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(t,e,r){if("message"in t){const n=t.serialize(),s=j.from(n).toString("base64");if(Array.isArray(e)||void 0!==r)throw new Error("Invalid arguments");const i=e||{};i.encoding="base64","commitment"in i||(i.commitment=this.commitment),e&&"object"==typeof e&&"innerInstructions"in e&&(i.innerInstructions=e.innerInstructions);const o=[s,i],a=await this._rpcRequest("simulateTransaction",o),c=_(a,Cr);if("error"in c)throw new Error("failed to simulate transaction: "+c.error.message);return c.result}let n;if(t instanceof be){let e=t;n=new be,n.feePayer=e.feePayer,n.instructions=t.instructions,n.nonceInfo=e.nonceInfo,n.signatures=e.signatures}else n=be.populate(t),n._message=n._json=void 0;if(void 0!==e&&!Array.isArray(e))throw new Error("Invalid arguments");const s=e;if(n.nonceInfo&&s)n.sign(...s);else{let t=this._disableBlockhashCaching;for(;;){const e=await this._blockhashWithExpiryBlockHeight(t);if(n.lastValidBlockHeight=e.lastValidBlockHeight,n.recentBlockhash=e.blockhash,!s)break;if(n.sign(...s),!n.signature)throw new Error("!signature");const r=n.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(r)&&!this._blockhashInfo.transactionSignatures.includes(r)){this._blockhashInfo.simulatedSignatures.push(r);break}t=!0}}const i=n._compile(),o=i.serialize(),a=n._serialize(o).toString("base64"),c={encoding:"base64",commitment:this.commitment};if(r){const t=(Array.isArray(r)?r:i.nonProgramIds()).map((t=>t.toBase58()));c.accounts={encoding:"base64",addresses:t}}s&&(c.sigVerify=!0),e&&"object"==typeof e&&"innerInstructions"in e&&(c.innerInstructions=e.innerInstructions);const u=[a,c],l=await this._rpcRequest("simulateTransaction",u),h=_(l,Cr);if("error"in h){let t;if("data"in h.error&&(t=h.error.data.logs,t&&Array.isArray(t))){const e="\n    ",r=e+t.join(e);console.error(h.error.message,r)}throw new Be({action:"simulate",signature:"",transactionMessage:h.error.message,logs:t})}return h.result}async sendTransaction(t,e,r){if("version"in t){if(e&&Array.isArray(e))throw new Error("Invalid arguments");const r=t.serialize();return await this.sendRawTransaction(r,e)}if(void 0===e||!Array.isArray(e))throw new Error("Invalid arguments");const n=e;if(t.nonceInfo)t.sign(...n);else{let e=this._disableBlockhashCaching;for(;;){const r=await this._blockhashWithExpiryBlockHeight(e);if(t.lastValidBlockHeight=r.lastValidBlockHeight,t.recentBlockhash=r.blockhash,t.sign(...n),!t.signature)throw new Error("!signature");const s=t.signature.toString("base64");if(!this._blockhashInfo.transactionSignatures.includes(s)){this._blockhashInfo.transactionSignatures.push(s);break}e=!0}}const s=t.serialize();return await this.sendRawTransaction(s,r)}async sendRawTransaction(t,e){const r=Kt(t).toString("base64");return await this.sendEncodedTransaction(r,e)}async sendEncodedTransaction(t,e){const r={encoding:"base64"},n=e&&e.skipPreflight,s=!0===n?"processed":e&&e.preflightCommitment||this.commitment;e&&null!=e.maxRetries&&(r.maxRetries=e.maxRetries),e&&null!=e.minContextSlot&&(r.minContextSlot=e.minContextSlot),n&&(r.skipPreflight=n),s&&(r.preflightCommitment=s);const i=[t,r],o=await this._rpcRequest("sendTransaction",i),a=_(o,Zn);if("error"in a){let t;throw"data"in a.error&&(t=a.error.data.logs),new Be({action:n?"send":"simulate",signature:"",transactionMessage:a.error.message,logs:t})}return a.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval((()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()}),5e3),this._updateSubscriptions()}_wsOnError(t){this._rpcWebSocketConnected=!1,console.error("ws error:",t.message)}_wsOnClose(t){this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),1e3!==t?(this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach((([t,e])=>{this._setSubscription(t,{...e,state:"pending"})}))):this._updateSubscriptions()}_setSubscription(t,e){const r=this._subscriptionsByHash[t]?.state;if(this._subscriptionsByHash[t]=e,r!==e.state){const r=this._subscriptionStateChangeCallbacksByHash[t];r&&r.forEach((t=>{try{t(e.state)}catch{}}))}}_onSubscriptionStateChange(t,e){const r=this._subscriptionHashByClientSubscriptionId[t];if(null==r)return()=>{};const n=this._subscriptionStateChangeCallbacksByHash[r]||=new Set;return n.add(e),()=>{n.delete(e),0===n.size&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(0===Object.keys(this._subscriptionsByHash).length)return void(this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout((()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(t){t instanceof Error&&console.log(`Error when closing socket connection: ${t.message}`)}}),500)));if(null!==this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected)return void this._rpcWebSocket.connect();const t=this._rpcWebSocketGeneration,e=()=>t===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map((async t=>{const r=this._subscriptionsByHash[t];if(void 0!==r)switch(r.state){case"pending":case"unsubscribed":if(0===r.callbacks.size)return delete this._subscriptionsByHash[t],"unsubscribed"===r.state&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],void await this._updateSubscriptions();await(async()=>{const{args:n,method:s}=r;try{this._setSubscription(t,{...r,state:"subscribing"});const e=await this._rpcWebSocket.call(s,n);this._setSubscription(t,{...r,serverSubscriptionId:e,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[e]=r.callbacks,await this._updateSubscriptions()}catch(i){if(i instanceof Error&&console.error(`${s} error for argument`,n,i.message),!e())return;this._setSubscription(t,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":0===r.callbacks.size&&await(async()=>{const{serverSubscriptionId:n,unsubscribeMethod:s}=r;if(this._subscriptionsAutoDisposedByRpc.has(n))this._subscriptionsAutoDisposedByRpc.delete(n);else{this._setSubscription(t,{...r,state:"unsubscribing"}),this._setSubscription(t,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(s,[n])}catch(n){if(n instanceof Error&&console.error(`${s} error:`,n.message),!e())return;return this._setSubscription(t,{...r,state:"subscribed"}),void await this._updateSubscriptions()}}this._setSubscription(t,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})()}})))}_handleServerNotification(t,e){const r=this._subscriptionCallbacksByServerSubscriptionId[t];void 0!==r&&r.forEach((t=>{try{t(...e)}catch(t){console.error(t)}}))}_wsOnAccountNotification(t){const{result:e,subscription:r}=_(t,rn);this._handleServerNotification(r,[e.value,e.context])}_makeSubscription(t,e){const r=this._nextClientSubscriptionId++,n=Qe([t.method,e]),s=this._subscriptionsByHash[n];return void 0===s?this._subscriptionsByHash[n]={...t,args:e,callbacks:new Set([t.callback]),state:"pending"}:s.callbacks.add(t.callback),this._subscriptionHashByClientSubscriptionId[r]=n,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const e=this._subscriptionsByHash[n];ae(void 0!==e,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),e.callbacks.delete(t.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(t,e,r){const{commitment:n,config:s}=hr(r),i=this._buildArgs([t.toBase58()],n||this._commitment||"finalized","base64",s);return this._makeSubscription({callback:e,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"account change")}_wsOnProgramAccountNotification(t){const{result:e,subscription:r}=_(t,sn);this._handleServerNotification(r,[{accountId:e.value.pubkey,accountInfo:e.value.account},e.context])}onProgramAccountChange(t,e,r,n){const{commitment:s,config:i}=hr(r),o=this._buildArgs([t.toBase58()],s||this._commitment||"finalized","base64",i||(n?{filters:dr(n)}:void 0));return this._makeSubscription({callback:e,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},o)}async removeProgramAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"program account change")}onLogs(t,e,r){const n=this._buildArgs(["object"==typeof t?{mentions:[t.toString()]}:t],r||this._commitment||"finalized");return this._makeSubscription({callback:e,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},n)}async removeOnLogsListener(t){await this._unsubscribeClientSubscription(t,"logs")}_wsOnLogsNotification(t){const{result:e,subscription:r}=_(t,ts);this._handleServerNotification(r,[e.value,e.context])}_wsOnSlotNotification(t){const{result:e,subscription:r}=_(t,an);this._handleServerNotification(r,[e])}onSlotChange(t){return this._makeSubscription({callback:t,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(t){await this._unsubscribeClientSubscription(t,"slot change")}_wsOnSlotUpdatesNotification(t){const{result:e,subscription:r}=_(t,un);this._handleServerNotification(r,[e])}onSlotUpdate(t){return this._makeSubscription({callback:t,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(t){await this._unsubscribeClientSubscription(t,"slot update")}async _unsubscribeClientSubscription(t,e){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[t];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${e}' events could not be found.`)}_buildArgs(t,e,r,n){const s=e||this._commitment;if(s||r||n){let e={};r&&(e.encoding=r),s&&(e.commitment=s),n&&(e=Object.assign(e,n)),t.push(e)}return t}_buildArgsAtLeastConfirmed(t,e,r,n){const s=e||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(t,e,r,n)}_wsOnSignatureNotification(t){const{result:e,subscription:r}=_(t,ln);"receivedSignature"!==e.value&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,"receivedSignature"===e.value?[{type:"received"},e.context]:[{type:"status",result:e.value},e.context])}onSignature(t,e,r){const n=this._buildArgs([t],r||this._commitment||"finalized"),s=this._makeSubscription({callback:(t,r)=>{if("status"===t.type){e(t.result,r);try{this.removeSignatureListener(s)}catch(t){}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},n);return s}onSignatureWithOptions(t,e,r){const{commitment:n,...s}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},i=this._buildArgs([t],n,void 0,s),o=this._makeSubscription({callback:(t,r)=>{e(t,r);try{this.removeSignatureListener(o)}catch(t){}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return o}async removeSignatureListener(t){await this._unsubscribeClientSubscription(t,"signature result")}_wsOnRootNotification(t){const{result:e,subscription:r}=_(t,hn);this._handleServerNotification(r,[e])}onRootChange(t){return this._makeSubscription({callback:t,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(t){await this._unsubscribeClientSubscription(t,"root change")}}class ns{constructor(t){this._keypair=void 0,this._keypair=t??Ct()}static generate(){return new ns(Ct())}static fromSecretKey(t,e){if(64!==t.byteLength)throw new Error("bad secret key size");const r=t.slice(32,64);if(!e||!e.skipValidation){const e=t.slice(0,32),n=Lt(e);for(let t=0;t<32;t++)if(r[t]!==n[t])throw new Error("provided secretKey is invalid")}return new ns({publicKey:r,secretKey:t})}static fromSeed(t){const e=Lt(t),r=new Uint8Array(64);return r.set(t),r.set(e,32),new ns({publicKey:e,secretKey:r})}get publicKey(){return new Ft(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const ss=Object.freeze({CreateLookupTable:{index:0,layout:a.struct([a.u32("instruction"),Me("recentSlot"),a.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:a.struct([a.u32("instruction")])},ExtendLookupTable:{index:2,layout:a.struct([a.u32("instruction"),Me(),a.seq(ee(),a.offset(a.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:a.struct([a.u32("instruction")])},CloseLookupTable:{index:4,layout:a.struct([a.u32("instruction")])}});class is{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const e=a.u32("instruction").decode(t.data);let r;for(const[t,n]of Object.entries(ss))if(n.index==e){r=t;break}if(!r)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return r}static decodeCreateLookupTable(t){this.checkProgramId(t.programId),this.checkKeysLength(t.keys,4);const{recentSlot:e}=Oe(ss.CreateLookupTable,t.data);return{authority:t.keys[1].pubkey,payer:t.keys[2].pubkey,recentSlot:Number(e)}}static decodeExtendLookupTable(t){if(this.checkProgramId(t.programId),t.keys.length<2)throw new Error(`invalid instruction; found ${t.keys.length} keys, expected at least 2`);const{addresses:e}=Oe(ss.ExtendLookupTable,t.data);return{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey,payer:t.keys.length>2?t.keys[2].pubkey:void 0,addresses:e.map((t=>new Ft(t)))}}static decodeCloseLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,3),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey,recipient:t.keys[2].pubkey}}static decodeFreezeLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,2),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey}}static decodeDeactivateLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,2),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey}}static checkProgramId(t){if(!t.equals(os.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}class os{constructor(){}static createLookupTable(t){const[e,r]=Ft.findProgramAddressSync([t.authority.toBuffer(),u(BigInt(t.recentSlot),8)],this.programId),n=We(ss.CreateLookupTable,{recentSlot:BigInt(t.recentSlot),bumpSeed:r}),s=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1},{pubkey:t.payer,isSigner:!0,isWritable:!0},{pubkey:Fe.programId,isSigner:!1,isWritable:!1}];return[new me({programId:this.programId,keys:s,data:n}),e]}static freezeLookupTable(t){const e=We(ss.FreezeLookupTable),r=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return new me({programId:this.programId,keys:r,data:e})}static extendLookupTable(t){const e=We(ss.ExtendLookupTable,{addresses:t.addresses.map((t=>t.toBytes()))}),r=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return t.payer&&r.push({pubkey:t.payer,isSigner:!0,isWritable:!0},{pubkey:Fe.programId,isSigner:!1,isWritable:!1}),new me({programId:this.programId,keys:r,data:e})}static deactivateLookupTable(t){const e=We(ss.DeactivateLookupTable),r=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return new me({programId:this.programId,keys:r,data:e})}static closeLookupTable(t){const e=We(ss.CloseLookupTable),r=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1},{pubkey:t.recipient,isSigner:!1,isWritable:!0}];return new me({programId:this.programId,keys:r,data:e})}}os.programId=new Ft("AddressLookupTab1e1111111111111111111111111");class as{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const e=a.u8("instruction").decode(t.data);let r;for(const[t,n]of Object.entries(cs))if(n.index==e){r=t;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(t){this.checkProgramId(t.programId);const{units:e,additionalFee:r}=Oe(cs.RequestUnits,t.data);return{units:e,additionalFee:r}}static decodeRequestHeapFrame(t){this.checkProgramId(t.programId);const{bytes:e}=Oe(cs.RequestHeapFrame,t.data);return{bytes:e}}static decodeSetComputeUnitLimit(t){this.checkProgramId(t.programId);const{units:e}=Oe(cs.SetComputeUnitLimit,t.data);return{units:e}}static decodeSetComputeUnitPrice(t){this.checkProgramId(t.programId);const{microLamports:e}=Oe(cs.SetComputeUnitPrice,t.data);return{microLamports:e}}static checkProgramId(t){if(!t.equals(us.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const cs=Object.freeze({RequestUnits:{index:0,layout:a.struct([a.u8("instruction"),a.u32("units"),a.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:a.struct([a.u8("instruction"),a.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:a.struct([a.u8("instruction"),a.u32("units")])},SetComputeUnitPrice:{index:3,layout:a.struct([a.u8("instruction"),Me("microLamports")])}});class us{constructor(){}static requestUnits(t){const e=We(cs.RequestUnits,t);return new me({keys:[],programId:this.programId,data:e})}static requestHeapFrame(t){const e=We(cs.RequestHeapFrame,t);return new me({keys:[],programId:this.programId,data:e})}static setComputeUnitLimit(t){const e=We(cs.SetComputeUnitLimit,t);return new me({keys:[],programId:this.programId,data:e})}static setComputeUnitPrice(t){const e=We(cs.SetComputeUnitPrice,{microLamports:BigInt(t.microLamports)});return new me({keys:[],programId:this.programId,data:e})}}us.programId=new Ft("ComputeBudget111111111111111111111111111111");const ls=a.struct([a.u8("numSignatures"),a.u8("padding"),a.u16("signatureOffset"),a.u16("signatureInstructionIndex"),a.u16("publicKeyOffset"),a.u16("publicKeyInstructionIndex"),a.u16("messageDataOffset"),a.u16("messageDataSize"),a.u16("messageInstructionIndex")]);class hs{constructor(){}static createInstructionWithPublicKey(t){const{publicKey:e,message:r,signature:n,instructionIndex:s}=t;ae(32===e.length,`Public Key must be 32 bytes but received ${e.length} bytes`),ae(64===n.length,`Signature must be 64 bytes but received ${n.length} bytes`);const i=ls.span,o=i+e.length,a=o+n.length,c=j.alloc(a+r.length),u=null==s?65535:s;return ls.encode({numSignatures:1,padding:0,signatureOffset:o,signatureInstructionIndex:u,publicKeyOffset:i,publicKeyInstructionIndex:u,messageDataOffset:a,messageDataSize:r.length,messageInstructionIndex:u},c),c.fill(e,i),c.fill(n,o),c.fill(r,a),new me({keys:[],programId:hs.programId,data:c})}static createInstructionWithPrivateKey(t){const{privateKey:e,message:r,instructionIndex:n}=t;ae(64===e.length,`Private key must be 64 bytes but received ${e.length} bytes`);try{const t=ns.fromSecretKey(e),s=t.publicKey.toBytes(),i=Wt(r,t.secretKey);return this.createInstructionWithPublicKey({publicKey:s,message:r,signature:i,instructionIndex:n})}catch(t){throw new Error(`Error creating instruction; ${t}`)}}}hs.programId=new Ft("Ed25519SigVerify111111111111111111111111111");C.utils.isValidPrivateKey;const ds=C.getPublicKey,gs=a.struct([a.u8("numSignatures"),a.u16("signatureOffset"),a.u8("signatureInstructionIndex"),a.u16("ethAddressOffset"),a.u8("ethAddressInstructionIndex"),a.u16("messageDataOffset"),a.u16("messageDataSize"),a.u8("messageInstructionIndex"),a.blob(20,"ethAddress"),a.blob(64,"signature"),a.u8("recoveryId")]);class ps{constructor(){}static publicKeyToEthAddress(t){ae(64===t.length,`Public key must be 64 bytes but received ${t.length} bytes`);try{return j.from(x(Kt(t))).slice(-20)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(t){const{publicKey:e,message:r,signature:n,recoveryId:s,instructionIndex:i}=t;return ps.createInstructionWithEthAddress({ethAddress:ps.publicKeyToEthAddress(e),message:r,signature:n,recoveryId:s,instructionIndex:i})}static createInstructionWithEthAddress(t){const{ethAddress:e,message:r,signature:n,recoveryId:s,instructionIndex:i=0}=t;let o;o="string"==typeof e?e.startsWith("0x")?j.from(e.substr(2),"hex"):j.from(e,"hex"):e,ae(20===o.length,`Address must be 20 bytes but received ${o.length} bytes`);const a=12+o.length,c=a+n.length+1,u=j.alloc(gs.span+r.length);return gs.encode({numSignatures:1,signatureOffset:a,signatureInstructionIndex:i,ethAddressOffset:12,ethAddressInstructionIndex:i,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:i,signature:Kt(n),ethAddress:Kt(o),recoveryId:s},u),u.fill(Kt(r),gs.span),new me({keys:[],programId:ps.programId,data:u})}static createInstructionWithPrivateKey(t){const{privateKey:e,message:r,instructionIndex:n}=t;ae(32===e.length,`Private key must be 32 bytes but received ${e.length} bytes`);try{const t=Kt(e),s=ds(t,!1).slice(1),i=j.from(x(Kt(r))),[o,a]=((t,e)=>{const r=C.sign(t,e);return[r.toCompactRawBytes(),r.recovery]})(i,t);return this.createInstructionWithPublicKey({publicKey:s,message:r,signature:o,recoveryId:a,instructionIndex:n})}catch(t){throw new Error(`Error creating instruction; ${t}`)}}}var ys;ps.programId=new Ft("KeccakSecp256k11111111111111111111111111111");const fs=new Ft("StakeConfig11111111111111111111111111111111");class ms{constructor(t,e){this.staker=void 0,this.withdrawer=void 0,this.staker=t,this.withdrawer=e}}class bs{constructor(t,e,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=r}}ys=bs,bs.default=new ys(0,0,Ft.default);class ks{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const e=a.u32("instruction").decode(t.data);let r;for(const[t,n]of Object.entries(ws))if(n.index==e){r=t;break}if(!r)throw new Error("Instruction type incorrect; not a StakeInstruction");return r}static decodeInitialize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{authorized:e,lockup:r}=Oe(ws.Initialize,t.data);return{stakePubkey:t.keys[0].pubkey,authorized:new ms(new Ft(e.staker),new Ft(e.withdrawer)),lockup:new bs(r.unixTimestamp,r.epoch,new Ft(r.custodian))}}static decodeDelegate(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,6),Oe(ws.Delegate,t.data),{stakePubkey:t.keys[0].pubkey,votePubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[5].pubkey}}static decodeAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{newAuthorized:e,stakeAuthorizationType:r}=Oe(ws.Authorize,t.data),n={stakePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey,newAuthorizedPubkey:new Ft(e),stakeAuthorizationType:{index:r}};return t.keys.length>3&&(n.custodianPubkey=t.keys[3].pubkey),n}static decodeAuthorizeWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{newAuthorized:e,stakeAuthorizationType:r,authoritySeed:n,authorityOwner:s}=Oe(ws.AuthorizeWithSeed,t.data),i={stakePubkey:t.keys[0].pubkey,authorityBase:t.keys[1].pubkey,authoritySeed:n,authorityOwner:new Ft(s),newAuthorizedPubkey:new Ft(e),stakeAuthorizationType:{index:r}};return t.keys.length>3&&(i.custodianPubkey=t.keys[3].pubkey),i}static decodeSplit(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e}=Oe(ws.Split,t.data);return{stakePubkey:t.keys[0].pubkey,splitStakePubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[2].pubkey,lamports:e}}static decodeMerge(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),Oe(ws.Merge,t.data),{stakePubkey:t.keys[0].pubkey,sourceStakePubKey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey}}static decodeWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,5);const{lamports:e}=Oe(ws.Withdraw,t.data),r={stakePubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey,lamports:e};return t.keys.length>5&&(r.custodianPubkey=t.keys[5].pubkey),r}static decodeDeactivate(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),Oe(ws.Deactivate,t.data),{stakePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey}}static checkProgramId(t){if(!t.equals(Is.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const ws=Object.freeze({Initialize:{index:0,layout:a.struct([a.u32("instruction"),((t="authorized")=>a.struct([ee("staker"),ee("withdrawer")],t))(),((t="lockup")=>a.struct([a.ns64("unixTimestamp"),a.ns64("epoch"),ee("custodian")],t))()])},Authorize:{index:1,layout:a.struct([a.u32("instruction"),ee("newAuthorized"),a.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:a.struct([a.u32("instruction")])},Split:{index:3,layout:a.struct([a.u32("instruction"),a.ns64("lamports")])},Withdraw:{index:4,layout:a.struct([a.u32("instruction"),a.ns64("lamports")])},Deactivate:{index:5,layout:a.struct([a.u32("instruction")])},Merge:{index:7,layout:a.struct([a.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:a.struct([a.u32("instruction"),ee("newAuthorized"),a.u32("stakeAuthorizationType"),ne("authoritySeed"),ee("authorityOwner")])}}),Ss=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class Is{constructor(){}static initialize(t){const{stakePubkey:e,authorized:r,lockup:n}=t,s=n||bs.default,i=We(ws.Initialize,{authorized:{staker:Kt(r.staker.toBuffer()),withdrawer:Kt(r.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:Kt(s.custodian.toBuffer())}}),o={keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1}],programId:this.programId,data:i};return new me(o)}static createAccountWithSeed(t){const e=new be;e.add(Fe.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.stakePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:s}=t;return e.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static createAccount(t){const e=new be;e.add(Fe.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.stakePubkey,lamports:t.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:n,lockup:s}=t;return e.add(this.initialize({stakePubkey:r,authorized:n,lockup:s}))}static delegate(t){const{stakePubkey:e,authorizedPubkey:r,votePubkey:n}=t,s=We(ws.Delegate);return(new be).add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Te,isSigner:!1,isWritable:!1},{pubkey:fs,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static authorize(t){const{stakePubkey:e,authorizedPubkey:r,newAuthorizedPubkey:n,stakeAuthorizationType:s,custodianPubkey:i}=t,o=We(ws.Authorize,{newAuthorized:Kt(n.toBuffer()),stakeAuthorizationType:s.index}),a=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&a.push({pubkey:i,isSigner:!0,isWritable:!1}),(new be).add({keys:a,programId:this.programId,data:o})}static authorizeWithSeed(t){const{stakePubkey:e,authorityBase:r,authoritySeed:n,authorityOwner:s,newAuthorizedPubkey:i,stakeAuthorizationType:o,custodianPubkey:a}=t,c=We(ws.AuthorizeWithSeed,{newAuthorized:Kt(i.toBuffer()),stakeAuthorizationType:o.index,authoritySeed:n,authorityOwner:Kt(s.toBuffer())}),u=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1}];return a&&u.push({pubkey:a,isSigner:!0,isWritable:!1}),(new be).add({keys:u,programId:this.programId,data:c})}static splitInstruction(t){const{stakePubkey:e,authorizedPubkey:r,splitStakePubkey:n,lamports:s}=t,i=We(ws.Split,{lamports:s});return new me({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static split(t,e){const r=new be;return r.add(Fe.createAccount({fromPubkey:t.authorizedPubkey,newAccountPubkey:t.splitStakePubkey,lamports:e,space:this.space,programId:this.programId})),r.add(this.splitInstruction(t))}static splitWithSeed(t,e){const{stakePubkey:r,authorizedPubkey:n,splitStakePubkey:s,basePubkey:i,seed:o,lamports:a}=t,c=new be;return c.add(Fe.allocate({accountPubkey:s,basePubkey:i,seed:o,space:this.space,programId:this.programId})),e&&e>0&&c.add(Fe.transfer({fromPubkey:t.authorizedPubkey,toPubkey:s,lamports:e})),c.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:n,splitStakePubkey:s,lamports:a}))}static merge(t){const{stakePubkey:e,sourceStakePubKey:r,authorizedPubkey:n}=t,s=We(ws.Merge);return(new be).add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Te,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}static withdraw(t){const{stakePubkey:e,authorizedPubkey:r,toPubkey:n,lamports:s,custodianPubkey:i}=t,o=We(ws.Withdraw,{lamports:s}),a=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:Te,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&a.push({pubkey:i,isSigner:!0,isWritable:!1}),(new be).add({keys:a,programId:this.programId,data:o})}static deactivate(t){const{stakePubkey:e,authorizedPubkey:r}=t,n=We(ws.Deactivate);return(new be).add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}}Is.programId=new Ft("Stake11111111111111111111111111111111111111"),Is.space=200;class As{constructor(t,e,r,n){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=t,this.authorizedVoter=e,this.authorizedWithdrawer=r,this.commission=n}}class vs{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const e=a.u32("instruction").decode(t.data);let r;for(const[t,n]of Object.entries(_s))if(n.index==e){r=t;break}if(!r)throw new Error("Instruction type incorrect; not a VoteInstruction");return r}static decodeInitializeAccount(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,4);const{voteInit:e}=Oe(_s.InitializeAccount,t.data);return{votePubkey:t.keys[0].pubkey,nodePubkey:t.keys[3].pubkey,voteInit:new As(new Ft(e.nodePubkey),new Ft(e.authorizedVoter),new Ft(e.authorizedWithdrawer),e.commission)}}static decodeAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{newAuthorized:e,voteAuthorizationType:r}=Oe(_s.Authorize,t.data);return{votePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey,newAuthorizedPubkey:new Ft(e),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:e,currentAuthorityDerivedKeySeed:r,newAuthorized:n,voteAuthorizationType:s}}=Oe(_s.AuthorizeWithSeed,t.data);return{currentAuthorityDerivedKeyBasePubkey:t.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new Ft(e),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new Ft(n),voteAuthorizationType:{index:s},votePubkey:t.keys[0].pubkey}}static decodeWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e}=Oe(_s.Withdraw,t.data);return{votePubkey:t.keys[0].pubkey,authorizedWithdrawerPubkey:t.keys[2].pubkey,lamports:e,toPubkey:t.keys[1].pubkey}}static checkProgramId(t){if(!t.equals(Es.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const _s=Object.freeze({InitializeAccount:{index:0,layout:a.struct([a.u32("instruction"),((t="voteInit")=>a.struct([ee("nodePubkey"),ee("authorizedVoter"),ee("authorizedWithdrawer"),a.u8("commission")],t))()])},Authorize:{index:1,layout:a.struct([a.u32("instruction"),ee("newAuthorized"),a.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:a.struct([a.u32("instruction"),a.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:a.struct([a.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:a.struct([a.u32("instruction"),((t="voteAuthorizeWithSeedArgs")=>a.struct([a.u32("voteAuthorizationType"),ee("currentAuthorityDerivedKeyOwnerPubkey"),ne("currentAuthorityDerivedKeySeed"),ee("newAuthorized")],t))()])}}),Ps=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Es{constructor(){}static initializeAccount(t){const{votePubkey:e,nodePubkey:r,voteInit:n}=t,s=We(_s.InitializeAccount,{voteInit:{nodePubkey:Kt(n.nodePubkey.toBuffer()),authorizedVoter:Kt(n.authorizedVoter.toBuffer()),authorizedWithdrawer:Kt(n.authorizedWithdrawer.toBuffer()),commission:n.commission}}),i={keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s};return new me(i)}static createAccount(t){const e=new be;return e.add(Fe.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.votePubkey,lamports:t.lamports,space:this.space,programId:this.programId})),e.add(this.initializeAccount({votePubkey:t.votePubkey,nodePubkey:t.voteInit.nodePubkey,voteInit:t.voteInit}))}static authorize(t){const{votePubkey:e,authorizedPubkey:r,newAuthorizedPubkey:n,voteAuthorizationType:s}=t,i=We(_s.Authorize,{newAuthorized:Kt(n.toBuffer()),voteAuthorizationType:s.index}),o=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new be).add({keys:o,programId:this.programId,data:i})}static authorizeWithSeed(t){const{currentAuthorityDerivedKeyBasePubkey:e,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:s,voteAuthorizationType:i,votePubkey:o}=t,a=We(_s.AuthorizeWithSeed,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:Kt(r.toBuffer()),currentAuthorityDerivedKeySeed:n,newAuthorized:Kt(s.toBuffer()),voteAuthorizationType:i.index}}),c=[{pubkey:o,isSigner:!1,isWritable:!0},{pubkey:Se,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1}];return(new be).add({keys:c,programId:this.programId,data:a})}static withdraw(t){const{votePubkey:e,authorizedWithdrawerPubkey:r,lamports:n,toPubkey:s}=t,i=We(_s.Withdraw,{lamports:n}),o=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return(new be).add({keys:o,programId:this.programId,data:i})}static safeWithdraw(t,e,r){if(t.lamports>e-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return Es.withdraw(t)}static updateValidatorIdentity(t){const{votePubkey:e,authorizedWithdrawerPubkey:r,nodePubkey:n}=t,s=We(_s.UpdateValidatorIdentity),i=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return(new be).add({keys:i,programId:this.programId,data:s})}}Es.programId=new Ft("Vote111111111111111111111111111111111111111"),Es.space=3762;const Rs=new Ft("Va1idator1nfo111111111111111111111111111111"),Ts=m({name:g(),website:S(g()),details:S(g()),iconUrl:S(g()),keybaseUsername:S(g())});class Bs{constructor(t,e){this.key=void 0,this.info=void 0,this.key=t,this.info=e}static fromConfigData(t){let e=[...t];if(2!==ie(e))return null;const r=[];for(let t=0;t<2;t++){const t=new Ft(he(e,0,Vt)),n=1===le(e);r.push({publicKey:t,isSigner:n})}if(r[0].publicKey.equals(Rs)&&r[1].isSigner){const t=ne().decode(j.from(e)),n=JSON.parse(t);return E(n,Ts),new Bs(r[1].publicKey,n)}return null}}const xs=new Ft("Vote111111111111111111111111111111111111111"),Cs=a.struct([ee("nodePubkey"),ee("authorizedWithdrawer"),a.u8("commission"),a.nu64(),a.seq(a.struct([a.nu64("slot"),a.u32("confirmationCount")]),a.offset(a.u32(),-8),"votes"),a.u8("rootSlotValid"),a.nu64("rootSlot"),a.nu64(),a.seq(a.struct([a.nu64("epoch"),ee("authorizedVoter")]),a.offset(a.u32(),-8),"authorizedVoters"),a.struct([a.seq(a.struct([ee("authorizedPubkey"),a.nu64("epochOfLastAuthorizedSwitch"),a.nu64("targetEpoch")]),32,"buf"),a.nu64("idx"),a.u8("isEmpty")],"priorVoters"),a.nu64(),a.seq(a.struct([a.nu64("epoch"),a.nu64("credits"),a.nu64("prevCredits")]),a.offset(a.u32(),-8),"epochCredits"),a.struct([a.nu64("slot"),a.nu64("timestamp")],"lastTimestamp")]);class Ls{constructor(t){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=t.nodePubkey,this.authorizedWithdrawer=t.authorizedWithdrawer,this.commission=t.commission,this.rootSlot=t.rootSlot,this.votes=t.votes,this.authorizedVoters=t.authorizedVoters,this.priorVoters=t.priorVoters,this.epochCredits=t.epochCredits,this.lastTimestamp=t.lastTimestamp}static fromAccountData(t){const e=Cs.decode(Kt(t),4);let r=e.rootSlot;return e.rootSlotValid||(r=null),new Ls({nodePubkey:new Ft(e.nodePubkey),authorizedWithdrawer:new Ft(e.authorizedWithdrawer),commission:e.commission,votes:e.votes,rootSlot:r,authorizedVoters:e.authorizedVoters.map(zs),priorVoters:Os(e.priorVoters),epochCredits:e.epochCredits,lastTimestamp:e.lastTimestamp})}}function zs({authorizedVoter:t,epoch:e}){return{epoch:e,authorizedVoter:new Ft(t)}}function Ws({authorizedPubkey:t,epochOfLastAuthorizedSwitch:e,targetEpoch:r}){return{authorizedPubkey:new Ft(t),epochOfLastAuthorizedSwitch:e,targetEpoch:r}}function Os({buf:t,idx:e,isEmpty:r}){return r?[]:[...t.slice(e+1).map(Ws),...t.slice(0,e).map(Ws)]}const Ks={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function Ns(t,e){const r=!1===e?"http":"https";if(!t)return Ks[r].devnet;const n=Ks[r][t];if(!n)throw new Error(`Unknown ${r} cluster: ${t}`);return n}async function Us(t,e,r,n){let s,i;r&&Object.prototype.hasOwnProperty.call(r,"lastValidBlockHeight")||r&&Object.prototype.hasOwnProperty.call(r,"nonceValue")?(s=r,i=n):i=r;const o=i&&{skipPreflight:i.skipPreflight,preflightCommitment:i.preflightCommitment||i.commitment,minContextSlot:i.minContextSlot},a=await t.sendRawTransaction(e,o),c=i&&i.commitment,u=s?t.confirmTransaction(s,c):t.confirmTransaction(a,c),l=(await u).value;if(l.err){if(null!=a)throw new Be({action:o?.skipPreflight?"send":"simulate",signature:a,transactionMessage:`Status: (${JSON.stringify(l)})`});throw new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`)}return a}const qs=1e9;export{Ht as Account,sr as AddressLookupTableAccount,is as AddressLookupTableInstruction,os as AddressLookupTableProgram,ms as Authorized,lr as BLOCKHASH_CACHE_TIMEOUT_MS,jt as BPF_LOADER_DEPRECATED_PROGRAM_ID,je as BPF_LOADER_PROGRAM_ID,Ye as BpfLoader,cs as COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,as as ComputeBudgetInstruction,us as ComputeBudgetProgram,rs as Connection,hs as Ed25519Program,Ut as Enum,er as EpochSchedule,Ke as FeeCalculatorLayout,ns as Keypair,qs as LAMPORTS_PER_SOL,ss as LOOKUP_TABLE_INSTRUCTION_LAYOUTS,He as Loader,bs as Lockup,Dt as MAX_SEED_LENGTH,de as Message,te as MessageAccountKeys,ge as MessageV0,Ue as NONCE_ACCOUNT_LENGTH,qe as NonceAccount,Yt as PACKET_DATA_SIZE,Vt as PUBLIC_KEY_LENGTH,Ft as PublicKey,Gt as SIGNATURE_LENGTH_IN_BYTES,qt as SOLANA_SCHEMA,fs as STAKE_CONFIG_ID,ws as STAKE_INSTRUCTION_LAYOUTS,$e as SYSTEM_INSTRUCTION_LAYOUTS,Se as SYSVAR_CLOCK_PUBKEY,Ie as SYSVAR_EPOCH_SCHEDULE_PUBKEY,Ae as SYSVAR_INSTRUCTIONS_PUBKEY,ve as SYSVAR_RECENT_BLOCKHASHES_PUBKEY,_e as SYSVAR_RENT_PUBKEY,Pe as SYSVAR_REWARDS_PUBKEY,Ee as SYSVAR_SLOT_HASHES_PUBKEY,Re as SYSVAR_SLOT_HISTORY_PUBKEY,Te as SYSVAR_STAKE_HISTORY_PUBKEY,ps as Secp256k1Program,Be as SendTransactionError,Ce as SolanaJSONRPCError,xe as SolanaJSONRPCErrorCode,Ss as StakeAuthorizationLayout,ks as StakeInstruction,Is as StakeProgram,Nt as Struct,Ve as SystemInstruction,Fe as SystemProgram,be as Transaction,Xt as TransactionExpiredBlockheightExceededError,Qt as TransactionExpiredNonceInvalidError,Zt as TransactionExpiredTimeoutError,me as TransactionInstruction,ke as TransactionMessage,ye as TransactionStatus,Rs as VALIDATOR_INFO_KEY,Jt as VERSION_PREFIX_MASK,xs as VOTE_PROGRAM_ID,Bs as ValidatorInfo,pe as VersionedMessage,we as VersionedTransaction,Ls as VoteAccount,Ps as VoteAuthorizationLayout,As as VoteInit,vs as VoteInstruction,Es as VoteProgram,Ns as clusterApiUrl,Us as sendAndConfirmRawTransaction,Le as sendAndConfirmTransaction};export default null;
//# sourceMappingURL=/sm/c825b3bfa2efddfa92016ed90e5c80eaa9b5039199f9fc84bb8bd14dda9c1226.map